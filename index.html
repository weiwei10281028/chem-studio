
<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>åˆ†å­çµæ§‹æ¨¡æ“¬å¯¦é©—å®¤ v16.13 (Plasma Fixed)</title>
<style>
/* --- 1. åŸºç¤è¨­å®š --- */
    :root {
        --bg-radial-inner: #000000; 
        --bg-radial-outer: #000000;
        --panel-glass: rgba(20, 20, 20, 0.9);
        --panel-border: rgba(255, 255, 255, 0.15);
        --card-glass: rgba(255, 255, 255, 0.05);
        --text-main: #f0f4f8;
        --text-sub: #94a3b8;
        --text-highlight: #38bdf8;
        --accent-blue: #3b82f6;
        --accent-green: #10b981;
    }

    * { box-sizing: border-box; user-select: none; -webkit-tap-highlight-color: transparent; }

    /* --- [ä¿®æ”¹] ä¸Šä¸‹æ¨™èˆ‡æ­£è² è™Ÿ åˆ†é›¢æ§åˆ¶å€ --- */
    
    /* 1. ä¸‹æ¨™è¨­å®š (æ§åˆ¶åŸå­æ•¸é‡ï¼Œå¦‚ H2 çš„ 2) */
    sub {
        font-size: 1.0em;      /* ä¸‹æ¨™å­—é«”å¤§å° */
        line-height: 1;
        position: relative;
        vertical-align: baseline;
        bottom: -0.2em;        /* ä¸‹æ¨™ä½ç½®ï¼šè¶Šè² è¶Šå¾€ä¸‹ */
    }

    /* 2. ä¸Šæ¨™è¨­å®š (æ§åˆ¶é›»è·çš„"æ•¸å­—"ï¼Œå¦‚ 3- çš„ 3) */
    sup {
        font-size: 1.0em;      /* ä¸Šæ¨™å­—é«”å¤§å° */
        line-height: 1;
        position: relative;
        vertical-align: baseline;
        top: -0.35em;          /* ä¸Šæ¨™ä½ç½®ï¼šè¶Šè² è¶Šå¾€ä¸Š */
        font-weight: bold;     /* ä¸Šæ¨™åŠ ç²—boldï¼Œæ­£å¸¸ç‚ºnormal */
        margin-left: 1px;      /* èˆ‡ä¸»æ–‡å­—çš„è·é›¢ */
    }

    /* 3. æ­£è² è™Ÿè¨­å®š (å°ˆé–€æ§åˆ¶ + èˆ‡ -ï¼Œå¦‚ 3- çš„ -) */
    .charge-sign {
        font-size: 1.4em;      /* æ­£è² è™Ÿå¯ä»¥è¨­å¤§ä¸€é»ï¼Œæ¯”è¼ƒæ¸…æ¥š */
        font-weight: bold;     /* æ­£è² è™ŸåŠ ç²— */
        position: relative;
        top: 0.05em;           /* æ­£è² è™Ÿå¾®èª¿ï¼šæ­£å€¼å¾€ä¸‹ï¼Œè² å€¼å¾€ä¸Š */
        margin-left: 0px;      /* æ­£è² è™Ÿèˆ‡æ•¸å­—çš„è·é›¢ */
    }

    body {
        margin: 0;
        font-family: 'Segoe UI', 'Microsoft JhengHei', 'Arial', sans-serif;
        background: radial-gradient(circle at center, var(--bg-radial-inner) 0%, var(--bg-radial-outer) 100%);
        color: var(--text-main);
        height: 100vh; overflow: hidden; display: flex; flex-direction: column;
        overscroll-behavior: none;
    }

    .app-container { display: flex; width: 100%; height: 100%; flex-direction: row; }

/* --- 3D é¡¯ç¤ºå€ --- */
    .viewport-area {
        flex: 1; position: relative;
        background-image: 
            linear-gradient(rgba(255,255,255,0.03) 1px, transparent 1px), 
            linear-gradient(90deg, rgba(255,255,255,0.03) 1px, transparent 1px);
        background-size: 60px 60px; 
        background-position: center center;
        overflow: hidden; cursor: grab;
        touch-action: none; 
        -webkit-user-select: none;
        will-change: transform;
        transform: translateZ(0);
    } 

    .viewport-header { 
        position: absolute; top: 20px; left: 25px; z-index: 10; pointer-events: none; 
        max-width: 80%;
    }

    .viewport-header h1 {
        margin: 0; 
        font-size: 1.6rem; /*ç¨å¾®å¤§ä¸€é»*/
        letter-spacing: 2px;
        /* æ”¹ç‚ºç´”ç™½ï¼Œä¸å†åŠé€æ˜ */
        color: #ffffff; 
        /* å¢å¼·å…‰æšˆæ•ˆæœï¼šé›™å±¤é™°å½±è®“å®ƒæ›´äº® */
        text-shadow: 0 0 10px rgba(56, 189, 248, 0.8), 0 0 20px rgba(56, 189, 248, 0.4);
        margin-bottom: 5px;
        display: flex;
        align-items: baseline; /* è®“ç‰ˆæœ¬è™Ÿå°é½Šæ–‡å­—åº•éƒ¨ */
        gap: 8px;
    }

    .molecule-display-info {
        margin-top: 5px;
        background: rgba(0, 0, 0, 0.6);
        backdrop-filter: blur(4px);
        padding: 10px 15px;
        border-radius: 12px;
        border-left: 4px solid var(--accent-blue);
        pointer-events: auto;
        display: inline-block;
    }

    .info-formula {
        font-size: 2.2rem;
        font-weight: 700;
        color: #fff;
        line-height: 1.1;
        text-shadow: 0 2px 10px rgba(0,0,0,0.5);
    }
    
    .info-name {
        font-size: 1.2rem;
        color: var(--text-highlight);
        font-weight: 500;
        margin-top: 4px;
    }

     .suggestions-container {
        position: fixed; z-index: 60; pointer-events: auto;
        display: grid; grid-template-columns: 1fr 1fr; gap: 8px; width: 170px;
        top: 80px; right: 25px; left: auto;   
    }

    .suggestion-label {
        grid-column: 1 / -1; 
        font-size: 0.85rem; color: rgba(255,255,255,0.7); margin-bottom: 2px;
        text-shadow: 0 1px 2px rgba(0,0,0,0.8); font-weight: bold; text-align: right; 
    }

    .suggestion-tag {
        background: rgba(40, 40, 40, 0.85);
        border: 1px solid rgba(255, 255, 255, 0.25);
        color: #eee; padding: 6px 0; border-radius: 12px; font-size: 0.85rem;
        cursor: pointer; transition: all 0.2s; backdrop-filter: blur(4px);
        box-shadow: 0 2px 5px rgba(0,0,0,0.4);
        display: flex; justify-content: center; align-items: center; width: 100%;
    }

    .suggestion-tag:hover {
        background: var(--accent-blue); color: #fff; border-color: var(--accent-blue);
        transform: translateY(-2px);
    }

    @media (max-width: 768px) {
        .suggestions-container { top: 20px; right: 15px; width: 160px; }
        .suggestion-tag { font-size: 0.75rem; padding: 5px 0; }
        .viewport-header { top: 15px; left: 15px; }
        .viewport-header h1 { font-size: 0.9rem; letter-spacing: 0.5px; }
        .molecule-display-info { padding: 8px 12px; }
        .info-formula { font-size: 1.8rem; }
        .info-name { font-size: 1rem; }
    }

    #viewport-subtitle { display: none; }
    #molecule-svg { position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; }
    #molecule-svg * { pointer-events: none; }

    .atom-label-text {
        font-family: 'Segoe UI', 'Arial', sans-serif; font-weight: 700; 
        text-anchor: middle; dominant-baseline: central; 
        fill: #ffffff; text-shadow: 0 0 4px #000;
    }

/* --- æ§åˆ¶é¢æ¿ --- */
    .controls-container {
        position: absolute; top: 25px; right: 25px; z-index: 50; 
        display: flex; gap: 15px; align-items: center; pointer-events: auto;
    }

    .control-button {
        padding: 8px 16px; border-radius: 20px; font-size: 0.9rem; font-weight: 600;
        border: 1px solid var(--panel-border); cursor: pointer; transition: all 0.3s;
        background: rgba(0, 0, 0, 0.4); color: var(--text-main);
        backdrop-filter: blur(4px); box-shadow: 0 4px 6px rgba(0,0,0,0.2);
    }
    .control-button.active { background: var(--accent-blue); border-color: var(--accent-blue); box-shadow: 0 0 15px var(--accent-blue); }

    .card { 
        background: var(--card-glass); border: 1px solid var(--panel-border); 
        border-radius: 16px; padding: 20px; margin-bottom: 20px; 
    }
    .card-title { 
        font-size: 1rem; font-weight: 700; color: var(--text-highlight); 
        margin-bottom: 15px; display: flex; align-items: center; gap: 10px; text-transform: uppercase; letter-spacing: 1px;
    }
    .data-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; padding-bottom: 10px; border-bottom: 1px solid rgba(255,255,255,0.05); }
    .data-label { font-size: 1rem; color: var(--text-sub); }
    .data-value { font-size: 1.15rem; color: var(--text-main); font-weight: 500; }
    
    .input-group { display: flex; gap: 8px; }
    .input-group input { 
        flex-grow: 1; padding: 12px; border: 1px solid var(--panel-border); border-radius: 8px; 
        background: rgba(0,0,0,0.3); color: white; transition: border 0.3s; outline: none; font-size: 1.1rem; 
    }
    .input-group button { 
        padding: 10px 20px; background: var(--accent-blue); color: white; border: none; border-radius: 8px; 
        cursor: pointer; font-weight: bold;
    }

    .switch-container { 
        display: flex; align-items: center; gap: 10px; margin-bottom: 10px; 
        background: rgba(0,0,0,0.2); padding: 12px; border-radius: 8px;
    }
    .switch-container input { width: 18px; height: 18px; accent-color: var(--accent-green); cursor: pointer; }

    #variant-selector {
        display: none; background: rgba(16, 185, 129, 0.05); border: 1px solid rgba(16, 185, 129, 0.2);
        padding: 15px; border-radius: 12px; margin-bottom: 15px;
    }
    .variant-option { padding: 5px 0; display: flex; align-items: center; gap: 10px; cursor: pointer; color: var(--accent-green); }

    #variant-selector.acid-theme { background: rgba(245, 158, 11, 0.05); border: 1px solid rgba(245, 158, 11, 0.3); }
    #variant-selector.acid-theme .variant-header { color: #fbbf24; }
    #variant-selector.acid-theme .variant-option { color: #fbbf24; }
    #variant-selector.acid-theme .variant-option:hover { background: rgba(245, 158, 11, 0.15); }

    #reaction-container { margin-bottom: 30px; width: 100%; }
    .reaction-row { display: flex; gap: 12px; width: 100%; flex-wrap: wrap; justify-content: center; }
    .reaction-btn {
        flex: 1 0 42%; max-width: 48%; min-width: 140px; height: 50px;
        padding: 0 10px; font-size: 0.95rem; font-weight: 600; color: white;
        border: none; border-radius: 50px; cursor: pointer;
        transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        display: none; align-items: center; justify-content: center; white-space: nowrap;
    }
    .reaction-btn:hover { transform: translateY(-2px); filter: brightness(1.1); box-shadow: 0 6px 16px rgba(0,0,0,0.3); }
    .reaction-btn:active { transform: translateY(1px); }

    .btn-h2o { background: linear-gradient(135deg, #3b82f6 0%, #2dd4bf 100%); }
    .btn-cl2 { background: linear-gradient(135deg, #0ea5e9 0%, #0284c7 100%); }
    .btn-h2  { background: linear-gradient(135deg, #ec4899 0%, #f43f5e 100%); }
    .btn-hcl { background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%); }
    .btn-kmno4 { background: linear-gradient(135deg, #8b5cf6 0%, #a855f7 100%); }
    
    @keyframes blurOutEffect { 0% { opacity: 1; filter: blur(0px); transform: scale(1); } 100% { opacity: 0; filter: blur(8px) brightness(1.5); transform: scale(1.05); } }
    @keyframes blurInEffect { 0% { opacity: 0; filter: blur(8px); transform: scale(0.95); } 100% { opacity: 1; filter: blur(0px); transform: scale(1); } }
    .scene-blur-out { animation: blurOutEffect 1.5s forwards ease-in; }
    .scene-blur-in { animation: blurInEffect 1.5s forwards ease-out; }

    .reset-btn {
        flex: 1; padding: 12px; background: rgba(255, 255, 255, 0.1);
        border: 1px solid var(--panel-border); color: var(--text-sub); border-radius: 12px;
        font-weight: bold; cursor: pointer; transition: all 0.2s;
    }
    .reset-btn:hover { background: rgba(255, 255, 255, 0.2); color: white; }

    /* æ‰‹æ©Ÿç‰ˆæ¨£å¼ */
    body.simulate-mobile .app-container { flex-direction: column; }
    body.simulate-mobile .controls-container { display: none !important; }
    body.simulate-mobile .viewport-area { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    body.simulate-mobile .controls-area {
        position: fixed; bottom: 0; left: 0; width: 100%; height: 70vh; max-height: 70vh;
        border-left: none; border-top: 1px solid rgba(255,255,255,0.15);
        border-radius: 20px 20px 0 0; background-color: #1a1a1a; padding: 0; z-index: 100;
        transform: translateY(0); transition: transform 0.3s; will-change: transform;
    }
    body.simulate-mobile #mobile-panel-handle {
        display: flex; width: 100%; height: 40px; justify-content: center; align-items: center;
        cursor: pointer; flex-shrink: 0; background: rgba(255,255,255,0.03); border-bottom: 1px solid rgba(255,255,255,0.05);
    }

    .controls-area { 
        width: 400px; min-width: 320px;
        background-color: var(--panel-glass);
        backdrop-filter: blur(15px); -webkit-backdrop-filter: blur(15px);
        border-left: 1px solid var(--panel-border);
        display: flex; flex-direction: column; 
        padding: 25px; overflow-y: auto; 
        box-shadow: -10px 0 30px rgba(0,0,0,0.5); 
        z-index: 20;
    }
    #mobile-panel-handle { display: none; }

    .input-note { font-size: 0.8rem; color: var(--text-sub); margin-top: 10px; line-height: 1.4; }
    .clickable-label { cursor: pointer; font-weight: bold; }
    .variant-header { font-weight: bold; color: var(--accent-green); margin-bottom: 5px; }

/* --- æ‰‹æ©Ÿç‰ˆæ¥µé€Ÿå„ªåŒ– (iOS Native Like) --- */
@media (max-width: 768px), (max-height: 500px) { 
    .app-container { flex-direction: column; height: 100vh; width: 100vw; overflow: hidden; position: relative; }
    .controls-container { display: none !important; } 
    .viewport-area { position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 0; }
    
    .controls-area {
        position: fixed; 
        left: 0; 
        bottom: 0; 
        width: 100%; 
        
        /* ã€é—œéµã€‘é«˜åº¦å›ºå®šï¼Œä¸è¦è®Šå‹•å®ƒï¼Œè®Šå‹•é«˜åº¦æœƒå¡é “ */
        height: 80vh; 
        
        background-color: rgba(26, 26, 26, 0.96); 
        backdrop-filter: blur(20px); -webkit-backdrop-filter: blur(20px);
        border-radius: 20px 20px 0 0; 
        border-top: 1px solid rgba(255,255,255,0.15);
        box-shadow: 0 -10px 40px rgba(0,0,0,0.6);
        z-index: 100;
        
        display: flex; flex-direction: column;
        padding: 0;

        /* ã€é—œéµã€‘é è¨­ä½ç½®ï¼šå¾€ä¸‹æ¨ (100% - 40pxæŠŠæ‰‹é«˜åº¦) */
        transform: translateY(calc(100% - 40px));
        
        /* å•Ÿç”¨ç¡¬é«”åŠ é€Ÿ */
        will-change: transform;
        /* é€™æ˜¯æ”¾æ‰‹å¾Œçš„å½ˆåŠ›æ›²ç·šï¼Œæ¨¡ä»¿ iOS */
        transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
    }

    #mobile-panel-handle { 
        display: flex; width: 100%; height: 40px; 
        justify-content: center; align-items: center;
        cursor: grab; flex-shrink: 0; 
        /* æŠŠæ‰‹èƒŒæ™¯ */
        background: rgba(255,255,255,0.02);
        border-bottom: 1px solid rgba(255,255,255,0.05); 
        touch-action: none; /* é‡è¦ï¼šé–å®šç€è¦½å™¨é è¨­æ»‘å‹• */
    }
    
    /* ä¿®æ”¹é€™è£¡ï¼šæŠŠæ‰‹çš„æ¨£å¼ */
    .handle-bar {
        width: 36px; 
        height: 5px; 
        background-color: rgba(255, 255, 255, 0.3); 
        border-radius: 10px;
        /* åŠ å…¥éæ¸¡å‹•ç•«ï¼Œè®“è®Šå¤§è®Šå°å¾ˆæ»‘é † */
        transition: all 0.25s cubic-bezier(0.2, 0.8, 0.2, 1);
    }

    /* æ–°å¢é€™è£¡ï¼šç•¶æŠŠæ‰‹è¢«æŒ‰ä½ (active) æ™‚çš„æ•ˆæœ */
    #mobile-panel-handle:active .handle-bar,
    #mobile-panel-handle.active .handle-bar {
        width: 55px; /* è®Šå¯¬ */
        background-color: rgba(255, 255, 255, 0.7); /* è®Šäº® */
        box-shadow: 0 0 10px rgba(255,255,255,0.3); /* åŠ ä¸€é»ç™¼å…‰ */
    }
    
    .controls-content { 
        flex: 1; 
        padding: 20px; 
        overflow-y: auto; 
        overscroll-behavior: contain;
        padding-bottom: 15px; /* å…¨é–‹çš„åº•éƒ¨ç•™ç™½ */
        transition: padding-bottom 0.4s ease;
    }

    .controls-area.half-open .controls-content {
        padding-bottom: 45vh; /* åŠé–‹çš„åº•éƒ¨ç•™ç™½ */
    }
}

    .hybrid-tooltip {
        position: fixed; top: 40%; left: 50%; transform: translate(-50%, -50%); 
        background: rgba(0, 0, 0, 0.9); color: #fff; padding: 15px 25px;
        border-radius: 12px; border: 2px solid var(--accent-green);
        font-family: 'Segoe UI', 'Arial', sans-serif; font-size: 1.4rem; font-weight: bold;
        pointer-events: none; opacity: 0; transition: opacity 0.2s;
        z-index: 9999; white-space: nowrap; text-align: center;
        box-shadow: 0 10px 30px rgba(0,0,0,0.8); text-shadow: 0 2px 4px #000;
        max-width: 90vw; 
    }
    
    /* --- çŸ¥è­˜å°ç™¾ç§‘å¡ç‰‡æ¨£å¼ --- */
    .knowledge-card {
        border: 1px solid rgba(251, 191, 36, 0.3); /* é‡‘é»ƒè‰²é‚Šæ¡† */
        background: linear-gradient(135deg, rgba(251, 191, 36, 0.05) 0%, rgba(0, 0, 0, 0.2) 100%);
        transition: all 0.3s ease;
    }

    .knowledge-card .card-title {
        color: #fbbf24; cursor: pointer; justify-content: space-between; margin-bottom: 0; 
    }

    .toggle-icon { font-size: 0.8rem; transition: transform 0.3s; color: #fbbf24; }
    .knowledge-card.expanded .toggle-icon { transform: rotate(180deg); }
    .knowledge-card.expanded .card-title { margin-bottom: 15px; padding-bottom: 10px; border-bottom: 1px solid rgba(251, 191, 36, 0.2); }
    .knowledge-content { display: none; font-size: 0.95rem; line-height: 1.6; color: #e2e8f0; text-align: justify; }
    .knowledge-content strong { color: #38bdf8; }
    .knowledge-card.expanded .knowledge-content { display: block; animation: fadeIn 0.4s ease; }

    @keyframes fadeIn { from { opacity: 0; transform: translateY(-5px); } to { opacity: 1; transform: translateY(0); } }

    .info-section { margin-bottom: 15px; }
    .info-title { font-weight: bold; color: #4ade80; margin-bottom: 8px; font-size: 1.05rem; border-left: 3px solid #4ade80; padding-left: 10px; letter-spacing: 1px; }
    .info-body { padding-left: 6px; font-size: 0.95rem; color: #f1f5f9; line-height: 1.7; text-align: justify; }
    .info-body strong { color: inherit; font-weight: 700; }
    .highlight-title { color: #38bdf8; font-weight: bold; display: inline-block; margin-right: 4px; }
    .hybrid-tooltip.show { opacity: 1; }

    /* é›»å­é–ƒçˆå‹•ç•« */
    @keyframes spark-flicker {
        0%, 100% { opacity: 1; transform: scale(1); }
        50% { opacity: 0.4; transform: scale(0.6); }
    }
    .electron-spark { animation: spark-flicker 0.15s linear infinite; }
    /* ========== [è«‹æ’å…¥é€™æ®µ CSS] é›»å­çµ„æ…‹è¡¨æ¨£å¼ ========== */
    #config-modal { display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); backdrop-filter: blur(8px); z-index: 200; justify-content: center; align-items: center; }
    .config-panel { background: #0f172a; border: 1px solid #334155; display: flex; flex-direction: column; width: 500px; height: 85vh; border-radius: 16px; box-shadow: 0 0 50px rgba(0,0,0,0.8); overflow: hidden; animation: slideUp 0.3s ease-out; }
    @keyframes slideUp { from { transform: translateY(50px); opacity: 0; } to { transform: translateY(0); opacity: 1; } }
    @media (max-width: 600px) { .config-panel { width: 100%; height: 100%; border-radius: 0; border: none; } }
    
    .config-header { padding: 15px; background: rgba(30,41,59,0.9); border-bottom: 1px solid #334155; display: flex; gap: 10px; align-items: center; }
    .config-close { background: transparent; border: none; color: #94a3b8; font-size: 1.5rem; cursor: pointer; padding: 0 10px; transition: 0.2s; } .config-close:hover { color: #fff; }
    .config-search { flex: 1; background: rgba(0,0,0,0.3); border: 1px solid #475569; color: #f1f5f9; padding: 12px; border-radius: 8px; font-size: 1rem; outline: none; }
    .config-list { flex: 1; overflow-y: auto; padding: 15px; }
    
    .element-card { background: rgba(30,41,59,0.4); border: 1px solid rgba(255,255,255,0.1); border-left: 3px solid #22d3ee; border-radius: 12px; padding: 15px; margin-bottom: 15px; position: relative; }
    .ec-header { display: flex; flex-direction: column; gap: 8px; margin-bottom: 12px; }
    .ec-top-row { display: flex; justify-content: space-between; align-items: center; width: 100%; }
    .ec-sym-box { display: flex; align-items: center; gap: 25px; }
    .ec-sym { font-size: 3.8rem; font-weight: 900; color: #fff; line-height: 1; min-width: 80px; text-align: center; text-shadow: 0 0 10px rgba(255,255,255,0.5), 0 0 30px rgba(255,255,255,0.2); }
    .ec-info { display: flex; flex-direction: column; gap: 2px; }
    .ec-name { font-size: 0.95rem; font-weight: bold; color: #fff; }
    .ec-meta { font-size: 0.75rem; color: #94a3b8; font-family: monospace; }
    .ec-tag { font-size: 0.75rem; color: #a78bfa; font-weight: 500; background: rgba(139, 92, 246, 0.15); padding: 2px 6px; border-radius: 4px; border: 1px solid rgba(139, 92, 246, 0.3); width: fit-content; }
    .ec-config-row { width: 100%; display: flex; justify-content: flex-end; background: rgba(0,0,0,0.3); padding: 6px 10px; border-radius: 6px; }
    .ec-config { font-family: 'Courier New', monospace; color: #a5f3fc; font-weight: bold; font-size: 1.1rem; letter-spacing: -0.5px; word-spacing: -2px; white-space: nowrap; }
    .ec-config sup { color: #22d3ee; font-size: 0.75em; vertical-align: super; }
    /* [ä¿®æ”¹] é–‹å•Ÿæ°´å¹³æ²è»¸ä¸¦ç¾åŒ–æ¨£å¼ */
    .ec-scroll { 
        width: 100%; 
        overflow-x: auto; /* å…è¨±æ©«å‘æ²å‹• */
        padding-top: 5px; 
        padding-bottom: 8px; /* å¢åŠ åº•éƒ¨ç©ºé–“çµ¦æ²è»¸ */
        border-top: 1px solid rgba(255,255,255,0.05); 
        scrollbar-width: thin; /* Firefox: ç´°æ²è»¸ */
        scrollbar-color: #475569 #0f172a; /* Firefox: é¡è‰² */
    }
    
    /* Chrome/Edge/Safari æ²è»¸æ¨£å¼ */
    .ec-scroll::-webkit-scrollbar { height: 6px; display: block; } /* è¨­å®šé«˜åº¦ä¸¦é¡¯ç¤º */
    .ec-scroll::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); border-radius: 3px; }
    .ec-scroll::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
    .ec-scroll::-webkit-scrollbar-thumb:hover { background: #22d3ee; } /* æ»‘é¼ ç§»éå»è®Šäº®è—è‰² */

    .ec-row { display: flex; gap: 8px; width: max-content; padding-right: 10px; }
    .ec-sub { display: flex; flex-direction: column; align-items: center; background: rgba(255,255,255,0.03); padding: 6px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.05); }
    .ec-boxes { display: flex; gap: 2px; }
    .ec-box { width: 32px; height: 32px; border: 1px solid #555; background: #000; display: flex; justify-content: center; align-items: center; font-size: 1.2rem; color: #facc15; font-weight: bold; }
    .ec-label { margin-top: 4px; font-size: 0.75rem; color: #64748b; font-family: monospace; }

    /* ========== [æ–°å¢] é›¢å­æŒ‰éˆ•äº’å‹•æ¨£å¼ ========== */
    .ion-btn {
    opacity: 0.8;
    border-width: 1px !important;
    font-weight: normal;
}

.ion-btn:active {
    opacity: 0.6; 
}

.ion-btn.active {
    opacity: 1;
    font-weight: bold;
    border-width: 2px !important;
    z-index: 2;
}

.ion-btn.active[data-type="neutral"] { background: #f1f5f9 !important; color: #000 !important; border-color: #fff !important; }
.ion-btn.active[data-type="pos"]     { background: #fca5a5 !important; color: #000 !important; border-color: #fca5a5 !important; }
.ion-btn.active[data-type="neg"]     { background: #93c5fd !important; color: #000 !important; border-color: #93c5fd !important; }


/* --- [æ–°å¢] å…±æŒ¯çµæ§‹ä¸»é¡Œ (ç´«è‰²ç³») --- */
#variant-selector.resonance-theme { 
    background: rgba(139, 92, 246, 0.05); 
    border: 1px solid rgba(139, 92, 246, 0.3); 
}
#variant-selector.resonance-theme .variant-header { 
    color: #a78bfa; /* æ·ºç´«è‰² */
}
#variant-selector.resonance-theme .variant-option { 
    color: #a78bfa; 
}
#variant-selector.resonance-theme .variant-option:hover { 
    background: rgba(139, 92, 246, 0.15); 
    color: #fff;
}
#variant-selector.resonance-theme input[type="radio"] {
    accent-color: #8b5cf6; /* ç´«è‰²é¸æ¡† */
}

/* --- [æ–°å¢] çµæ§‹/æ™¶é«”åˆ‡æ›ä¸»é¡Œ (è—è‰²ç³») --- */
#variant-selector.structure-theme { 
    background: rgba(56, 189, 248, 0.05); /* å¤©è—è‰²èƒŒæ™¯ */
    border: 1px solid rgba(56, 189, 248, 0.3); 
}
#variant-selector.structure-theme .variant-header { 
    color: #38bdf8; /* å¤©è—è‰²æ–‡å­— */
}
#variant-selector.structure-theme .variant-option { 
    color: #38bdf8; 
}
#variant-selector.structure-theme .variant-option:hover { 
    background: rgba(56, 189, 248, 0.15); 
    color: #fff;
}
#variant-selector.structure-theme input[type="radio"] {
    accent-color: #0ea5e9; /* è—è‰²é¸æ¡† */
}


/* --- è»ŒåŸŸæ§åˆ¶é¢æ¿æ¨£å¼ --- */
.orbital-btn-group {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: 8px;
    margin-bottom: 10px;
}
.orb-btn {
    background: rgba(255, 255, 255, 0.05);
    border: 1px solid rgba(56, 189, 248, 0.3);
    color: #38bdf8;
    padding: 6px 0;
    border-radius: 8px;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s;
    font-family: 'Times New Roman', serif; /* è®“è»ŒåŸŸç¬¦è™Ÿæ›´æœ‰å­¸è¡“æ„Ÿ */
    font-style: italic;
}
.orb-btn:hover {
    background: rgba(56, 189, 248, 0.2);
    box-shadow: 0 0 10px rgba(56, 189, 248, 0.3);
}
.orb-btn.active {
    background: #38bdf8;
    color: #000;
    font-weight: bold;
    box-shadow: 0 0 15px rgba(56, 189, 248, 0.6);
}

/* é–‹é—œç¯€é¢æŒ‰éˆ• */
.plane-toggle {
    width: 100%;
    margin-top: 5px;
    background: linear-gradient(90deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
    border: 1px solid rgba(255,255,255,0.2);
    color: #e2e8f0;
}
.plane-toggle.active {
    background: linear-gradient(90deg, #10b981, #059669);
    border-color: #10b981;
    color: white;
}

.orbital-btn-group {
    display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 10px;
}
.orb-btn {
    background: rgba(255, 255, 255, 0.05); border: 1px solid rgba(56, 189, 248, 0.3); color: #38bdf8;
    padding: 6px 0; border-radius: 8px; font-size: 0.9rem; cursor: pointer; transition: all 0.2s;
    font-family: 'Times New Roman', serif; font-style: italic;
}
.orb-btn:hover { background: rgba(56, 189, 248, 0.2); box-shadow: 0 0 10px rgba(56, 189, 248, 0.3); }
.orb-btn.active { background: #38bdf8; color: #000; font-weight: bold; box-shadow: 0 0 15px rgba(56, 189, 248, 0.6); }
.plane-toggle {
    width: 100%; margin-top: 5px; background: linear-gradient(90deg, rgba(255,255,255,0.1), rgba(255,255,255,0.05));
    border: 1px solid rgba(255,255,255,0.2); color: #e2e8f0;
}
.plane-toggle.active { background: linear-gradient(90deg, #10b981, #059669); border-color: #10b981; color: white; }




</style>
</head>
<body>

<div class="app-container">
    <div class="viewport-area" id="viewport">
        <!-- æ¨™é¡Œèˆ‡è³‡è¨Šé¡¯ç¤ºå€ -->
        <div class="viewport-header">
            <h1 class="title">MOLECULAR SIMULATOR</h1>
            
            <div class="molecule-display-info" id="molecule-display-info">
                <div class="info-formula" id="info-formula"></div>
                <div class="info-name" id="info-name"></div>
            </div>

            <!-- çŒœä½ æƒ³çœ‹åŠŸèƒ½ -->
            <div class="suggestions-container" id="suggestions-container">
                <div class="suggestion-label">ä½ å¯èƒ½é‚„æƒ³çœ‹ï¼š</div>
            </div>

            <span class="input-note" id="viewport-subtitle"></span>
        </div>
        
        <div class="controls-container">
            <button id="mode-toggle" class="control-button active">æ¨¡å¼: è¤‡åˆ</button>
        </div>

        <svg id="molecule-svg" viewBox="-400 -300 800 600" preserveAspectRatio="xMidYMid slice">
            <defs>
                <filter id="soft-glow" x="-300%" y="-300%" width="700%" height="700%" filterUnits="objectBoundingBox" color-interpolation-filters="sRGB">
                    <feGaussianBlur in="SourceGraphic" stdDeviation="3.5" />
                </filter>
            </defs>
            <g id="scene-root"></g>
        </svg>
        <div id="hybrid-label" class="hybrid-tooltip"></div>
    </div>
    <div id="config-modal">
        <div class="config-panel">
            <div class="config-header">
                <button class="config-close" onclick="closeConfigModal()">âœ•</button>
                <input type="text" class="config-search" id="configSearchInput" placeholder="æœå°‹å…ƒç´  (Ex: Fe, 26, Carbon)..." onkeyup="renderConfigList()">
            </div>
            <div class="config-list" id="configListContainer"></div>
        </div>
    </div>

    <div class="controls-area" id="controls-panel">
        <div id="mobile-panel-handle"><div class="handle-bar"></div></div>
        
        <div class="controls-content">
            <div class="card">
                <div class="card-title" style="display: flex; justify-content: space-between; align-items: center;">
    <span>âš›ï¸ è¼¸å…¥åŒ–å­¸å¼</span>
    <span style="font-size: 14px; color: #ffffff; text-shadow: 0 0 8px rgba(255, 255, 255, 0.9); font-weight: normal; letter-spacing: 0.5px;">
        Created by æ—ç‘‹è€å¸«
    </span>
</div>
                <div class="input-group">
                    <input type="text" id="formula-input" placeholder="Ex: P4O6, C60, è‹¯..." value="P4O6">
                    <button id="load-btn">è¼‰å…¥</button>
                </div>
                <div class="input-note">å–®æŒ‡æ»‘å‹•æ—‹è½‰ï¼Œé›™æŒ‡ç¸®æ”¾/å¹³ç§»</div>
            </div>

            <div class="switch-container">
                <input type="checkbox" id="toggle-lp" checked>
                <label for="toggle-lp" class="clickable-label">é¡¯ç¤ºå­¤å°é›»å­ (3D)</label>
            </div>

            <div class="switch-container" id="glow-switch-wrap">
                <input type="checkbox" id="toggle-glow">
                <label for="toggle-glow" class="clickable-label">é¡¯ç¤ºåŸå­å…‰æšˆ (Glow)</label>
            </div>
            
            <div class="switch-container">
                <input type="checkbox" id="toggle-octet" checked>
                <label for="toggle-octet" class="clickable-label">å„ªå…ˆéµå¾ªå…«éš…é«”</label>
            </div>
            <div class="switch-container">
                <input type="checkbox" id="toggle-auto-rotate" checked>
                <label for="toggle-auto-rotate" class="clickable-label">é–’ç½®è‡ªå‹•æ—‹è½‰</label>
            </div>

            <div id="variant-selector"></div>
            
            <div class="switch-container">
                <input type="checkbox" id="toggle-plasma">
                <label for="toggle-plasma" class="clickable-label" style="color:#a5f3fc; text-shadow:0 0 5px #a5f3fc; font-weight:bold;">âš¡ é–‹å•Ÿé›»æ¼¿æ…‹æ¨¡å¼</label>
            </div>

            <div id="reaction-container">
                <div class="reaction-row">
                    <button id="reaction-btn" class="reaction-btn btn-h2o">ğŸ§ª æ°´åŠ æˆ</button>
                    <button id="reaction-h2-btn" class="reaction-btn btn-h2">ğŸ§ª æ°«æ°£åŠ æˆ</button>
                    <button id="reaction-hcl-btn" class="reaction-btn btn-hcl">ğŸ§ª é¹µåŒ–æ°«åŠ æˆ</button>
                    <button id="reaction-cl2-btn" class="reaction-btn btn-cl2">ğŸ§ª é¹µç´ åŠ æˆ</button>
                    <button id="reaction-kmno4-btn" class="reaction-btn btn-kmno4">ğŸ§ª KMnO4 æ°§åŒ–</button>
                    <button id="reaction-sub-btn" class="reaction-btn btn-cl2">ğŸ§ª é¹µç´ å–ä»£</button>
                    <button id="reaction-nitro-btn" class="reaction-btn btn-hcl">ğŸ§ª ç¡é…¸å–ä»£</button>
                    <button id="reaction-propene-h2-btn"  class="reaction-btn btn-h2">ğŸ§ª æ°«æ°£åŠ æˆ</button>
                    <button id="reaction-propene-cl2-btn" class="reaction-btn btn-cl2">ğŸ§ª é¹µç´ åŠ æˆ</button>
                    <button id="reaction-propene-hcl-btn" class="reaction-btn btn-hcl">ğŸ§ª é¹µåŒ–æ°«åŠ æˆ</button>
                    <button id="reaction-propene-h2o-btn" class="reaction-btn btn-h2o">ğŸ§ª æ°´åŠ æˆ</button>
                    <button id="reaction-ox-btn" class="reaction-btn btn-kmno4">ğŸ§ª ä¸€èˆ¬æ°§åŒ–</button>
                    <button id="reaction-red-btn" class="reaction-btn btn-h2">ğŸ§ª é‚„åŸ</button>
                    <!-- [æ–°å¢] ä¹™ç‚” (C2H2) å°ˆç”¨æŒ‰éˆ•ç¾¤ (å…±7å€‹) -->
        <button id="btn-c2h2-h2-full" class="reaction-btn btn-h2">ğŸ§ª æ°«æ°£ (å®Œå…¨)</button>
        <button id="btn-c2h2-h2-part" class="reaction-btn btn-h2" style="border: 2px dashed #f472b6;">ğŸ§ª æ°«æ°£ (éƒ¨åˆ†)</button>
        <button id="btn-c2h2-cl2-full" class="reaction-btn btn-cl2">ğŸ§ª é¹µç´  (å®Œå…¨)</button>
        <button id="btn-c2h2-cl2-part" class="reaction-btn btn-cl2" style="border: 2px dashed #38bdf8;">ğŸ§ª é¹µç´  (éƒ¨åˆ†)</button>       
        <button id="btn-c2h2-hcl-full" class="reaction-btn btn-hcl">ğŸ§ª é¹µåŒ–æ°« (å®Œå…¨)</button>
        <button id="btn-c2h2-hcl-part" class="reaction-btn btn-hcl" style="border: 2px dashed #fbbf24;">ğŸ§ª é¹µåŒ–æ°« (éƒ¨åˆ†)</button> 
        <button id="btn-c2h2-h2o" class="reaction-btn btn-h2o">ğŸ§ª æ°´åŠ æˆ</button>
                    <button id="reset-btn" class="reset-btn">â†º é‡ç½®</button>
                </div>
            </div>
            <!-- çŸ¥è­˜å°ç™¾ç§‘å¡ç‰‡ -->
            <div class="card knowledge-card" id="knowledge-card" style="display: none;">
            <div class="card-title" onclick="toggleKnowledge()">
            <span>ğŸ’¡ å°çŸ¥è­˜</span>
            <span class="toggle-icon">â–¼</span>
            </div>
            <div class="knowledge-content" id="knowledge-text">
            </div>
        </div>
        <button id="btn-open-config" class="control-button" style="width:100%; margin-bottom:15px; background:rgba(34, 211, 238, 0.1); border:1px solid #22d3ee; color:#22d3ee; font-weight:bold;">
            âš›ï¸ æŸ¥è©¢é›»å­çµ„æ…‹ (1-118)
        </button>
            
            
            <div class="card" id="data-card">
                <div class="card-title">ğŸ“Š ç‰©è³ªè³‡æ–™</div>
                <div class="data-row"><span class="data-label" id="lbl-formula">åŒ–å­¸å¼</span><span class="data-value" id="disp-formula"></span></div>
                <div class="data-row"><span class="data-label" id="lbl-name">ä¸­æ–‡åç¨±</span><span class="data-value" id="disp-center"></span></div>
                <div class="data-row"><span class="data-label" id="lbl-hybrid">æ··æˆè»ŒåŸŸ</span><span class="data-value" id="disp-hybrid"></span></div>
                <div class="data-row"><span class="data-label" id="lbl-shape">å½¢ç‹€</span><span class="data-value" id="disp-shape"></span></div>
                <div class="data-row"><span class="data-label" id="lbl-angle">éµè§’</span><span class="data-value" id="disp-angle"></span></div>
                <div class="data-row"><span class="data-label" id="lbl-mp">ç†”é» (MP)</span><span class="data-value" id="disp-mp"></span></div>
                <div class="data-row"><span class="data-label" id="lbl-bp">æ²¸é» (BP)</span><span class="data-value" id="disp-bp"></span></div>
                <div class="data-row"><span class="data-label" id="lbl-bonds">éµçµçµ±è¨ˆ</span><span class="data-value" id="disp-bonds"></span></div>
                <div class="data-row"><span class="data-label" id="lbl-mass">åˆ†å­é‡</span><span class="data-value" id="disp-mass"></span></div>
            </div>
            <div class="spacer-60"></div>
        </div>
    </div>
</div>

<!-- [ä¿®æ­£ç‰ˆ] éš±è—çš„æµé‡è¨ˆæ•¸å™¨ (ä½¿ç”¨ Hits.sh) -->
<!-- ID å·²ä¿®æ­£ç‚ºç¶²åŸŸæ ¼å¼ä»¥ç¬¦åˆæœå‹™è¦æ±‚: weiwei-molecular-lab.app -->
<div style="display:none;">
    <img id="site_counter_img" 
         src="https://hits.sh/weiwei-molecular-lab.app.svg?label=Views&color=10b981&labelColor=2d3748" 
         alt="Page Views">
</div>

<script src="data_static.js"></script>
<script src="data_molecules.js"></script>
<script>
// ==========================================
// 1. ç³»çµ±åˆå§‹åŒ–
// ==========================================
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) || window.innerWidth < 768;
let isReactionRunning = false; 
let isReactionFinished = false; 
let isPlasmaMode = false; // [ä¿®å¾©] ç¢ºä¿è®Šæ•¸å­˜åœ¨

/*
 ==========================================================================
 â˜… è¦–è¦ºéµé•·æ¨™æº–åƒè€ƒè¡¨ (Visual Bond Length Standards) v16.2
 ==========================================================================
 åŸºæº–ï¼šä»¥ 1,2-äºŒæ°¯ä¸™çƒ·ç‚ºéŒ¨é» (C-C ~ 70, C-H ~ 50, C-Cl ~ 75)
 
 [1] åŸå­è¦–è¦ºåŠå¾‘è²¢ç» (Base Radius Contribution)
 --------------------------------------------------------------------------
  - H (æ°«) .................... 15  (æœ€å°ï¼Œç¢ºä¿ç·Šæ¹Š)
  - Row 2 (C, N, O, F) ........ 35  (åŸºæº–)
  - Row 3 (Si, P, S, Cl) ...... 40  (ç•¥å¤§)
  - Row 4 (Br) ................ 45
  - Row 5 (I, Xe) ............. 50  (æœ€å¤§)

 [2] éµç´šä¿®æ­£ä¿‚æ•¸ (Bond Order Multiplier)
 --------------------------------------------------------------------------
  - å–®éµ (Single) ............. x 1.00
  - é›™éµ (Double) ............. x 0.90
  - åƒéµ (Triple) ............. x 0.85

 [3] å¸¸è¦‹éµé•·è¨ˆç®—ç¯„ä¾‹ (Calculated Examples)
 --------------------------------------------------------------------------
  Type      Calc (R1 + R2) * Multiplier      Final Value
  -------   ---------------------------      -----------
  H-H       (15 + 15) * 1.0                  30
  C-H       (35 + 15) * 1.0                  50  (åŸºæº–)
  N-H       (35 + 15) * 1.0                  50
  O-H       (35 + 15) * 1.0                  50
  P-H       (40 + 15) * 1.0                  55

  C-C       (35 + 35) * 1.0                  70  (åŸºæº–)
  C=C       (35 + 35) * 0.9                  63
  Câ‰¡C       (35 + 35) * 0.85                 60
  
  C-O       (35 + 35) * 1.0                  70
  C=O       (35 + 35) * 0.9                  63

  S-O       (40 + 35) * 1.0                  75
  S=O       (40 + 35) * 0.9                  68  (SO4, SO3)
  
  P-Cl      (40 + 40) * 1.0                  80  (PCl3)
  Xe=O      (50 + 35) * 0.9                  76  (XeO3)
  
  F-F       (35 + 35) * 1.0                  70
  Cl-Cl     (40 + 40) * 1.0                  80
  I-I       (50 + 50) * 1.0                  100
 ==========================================================================
*/





// --- [æ–°å¢] ç”¨ä¾†å„²å­˜åæ‡‰æ­·å²ç´€éŒ„ ---
let moleculeHistory = [];

function autoAssignLonePairs(atom, bonds, allAtoms) {
    if (atom.lp3d !== undefined && atom.lp3d.length > 0) return atom.lpCount || atom.lp3d.length;
    if (atom.lpCount !== undefined) return atom.lpCount;
    const props = ELEMENT_PROPS[atom.elem]; if (!props) return 0;
    const valence = props.ve; const en = props.en || 0;
    let bondElectronCount = 0; let neighborCount = 0;
    const myIndex = atom.originalIndex;
    bonds.forEach(b => {
        if (b[0] !== myIndex && b[1] !== myIndex) return;
        neighborCount++; 
        let type = b[2] || "single";
        if (type.includes("triple")) bondElectronCount += 3;
        else if (type.includes("double")) bondElectronCount += 2;
        else if (type === "coordinate") { if (b[0] === myIndex) bondElectronCount += 2; }
        else if (type === "coordinate_triple") bondElectronCount += 3;
        else bondElectronCount += 1;
    });
    let remainingElectrons = valence - bondElectronCount;
    if (remainingElectrons % 2 !== 0 && !atom.radical) {
        if (neighborCount === 1 && en > 2.5) remainingElectrons += 1;
    }
    let lp = Math.floor(remainingElectrons / 2);
    return Math.max(0, lp);
}
function generateElectronDots(atom, atomIndex, allAtoms, allBonds) {
    const dots = []; 
    let lpCount = atom.calculatedLP;
    // å¦‚æœæ²’æœ‰å­¤å°é›»å­ä¸”ä¸æ˜¯è‡ªç”±åŸºï¼Œç›´æ¥è¿”å›ç©ºé™£åˆ—
    if (lpCount <= 0 && !atom.radical) return dots;

    // --- 1. å¹¾ä½•ä½ç½®è¨ˆç®— (ç¶­æŒåŸæœ‰çš„ 3D å‘é‡é‹ç®—) ---
    if (atom.lp3d && atom.lp3d.length > 0) {
        // å¦‚æœæœ‰æ‰‹å‹•æŒ‡å®šçš„åº§æ¨™ (hardcoded)
        const pushDist = atom.r * 2.2; 
        atom.lp3d.forEach(v => {
            const len = Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z) || 1;
            addPairToDots(dots, atom, { x: (v.x/len)*pushDist, y: (v.y/len)*pushDist, z: (v.z/len)*pushDist });
        });
    } else {
        // è‡ªå‹•è¨ˆç®—ï¼šæ ¹æ“šéµçµå‘é‡æ¨ç®—å­¤å°é›»å­ä½ç½®
        const myBonds = allBonds.filter(b => b[0] === atomIndex || b[1] === atomIndex);
        let bondVectors = [];
        myBonds.forEach(b => {
            const otherIdx = (b[0] === atomIndex) ? b[1] : b[0];
            const other = allAtoms[otherIdx];
            let vx = other.x - atom.x, vy = other.y - atom.y, vz = other.z - atom.z;
            const len = Math.sqrt(vx*vx + vy*vy + vz*vz) || 1;
            bondVectors.push({ x: vx/len, y: vy/len, z: vz/len, style: b[2] });
        });
        
        let sumX = 0, sumY = 0, sumZ = 0;
        if (bondVectors.length > 0) { bondVectors.forEach(v => { sumX += v.x; sumY += v.y; sumZ += v.z; }); } 
        else { sumX = 0; sumY = -1; sumZ = 0; }
        
        let backX = -sumX, backY = -sumY, backZ = -sumZ;
        let backLen = Math.sqrt(backX*backX + backY*backY + backZ*backZ);
        if (backLen < 0.001) { backX=0; backY=1; backZ=0; backLen=1; }
        backX /= backLen; backY /= backLen; backZ /= backLen;
        
        let ux = backX, uy = backY, uz = backZ;
        let tempX = 0, tempY = 1, tempZ = 0;
        if (Math.abs(ux) < 0.1 && Math.abs(uz) < 0.1) { tempX=1; tempY=0; tempZ=0; }
        let wx = uy*tempZ - uz*tempY, wy = uz*tempX - ux*tempZ, wz = ux*tempY - uy*tempX;
        let wLen = Math.sqrt(wx*wx + wy*wy + wz*wz);
        wx/=wLen; wy/=wLen; wz/=wLen;
        let vx = wy*uz - wz*uy, vy = wz*ux - wx*uz, vz = wx*uy - wy*ux;
        
        const lpDist = atom.r * 2.2;
        const pushLP = (dx, dy, dz) => { addPairToDots(dots, atom, { x: dx*lpDist, y: dy*lpDist, z: dz*lpDist }); };

        if (bondVectors.length === 1) {
            if (lpCount === 3) {
                const angle = 70 * (Math.PI/180); const sinA = Math.sin(angle); const cosA = Math.cos(angle);
                for(let i=0; i<3; i++) {
                    const theta = i * (120 * Math.PI/180);
                    const px = cosA * ux + sinA * (Math.cos(theta)*vx + Math.sin(theta)*wx);
                    const py = cosA * uy + sinA * (Math.cos(theta)*vy + Math.sin(theta)*wy);
                    const pz = cosA * uz + sinA * (Math.cos(theta)*vz + Math.sin(theta)*wz);
                    pushLP(px, py, pz);
                }
            } else if (lpCount === 2) {
                const angle = 60 * (Math.PI/180);
                pushLP(Math.cos(angle)*ux + Math.sin(angle)*vx, Math.cos(angle)*uy + Math.sin(angle)*vy, Math.cos(angle)*uz + Math.sin(angle)*vz);
                pushLP(Math.cos(angle)*ux - Math.sin(angle)*vx, Math.cos(angle)*uy - Math.sin(angle)*vy, Math.cos(angle)*uz - Math.sin(angle)*vz);
            } else if (lpCount === 1) { pushLP(ux, uy, uz); }
        } else if (bondVectors.length === 2) {
            if (lpCount === 2) {
                let b1 = bondVectors[0], b2 = bondVectors[1];
                let nx = b1.y*b2.z - b1.z*b2.y, ny = b1.z*b2.x - b1.x*b2.z, nz = b1.x*b2.y - b1.y*b2.x;
                let nLen = Math.sqrt(nx*nx + ny*ny + nz*nz);
                if (nLen > 0.001) { nx/=nLen; ny/=nLen; nz/=nLen; } else { nx=vx; ny=vy; nz=vz; }
                const tilt = 50 * (Math.PI/180);
                pushLP(Math.cos(tilt)*ux + Math.sin(tilt)*nx, Math.cos(tilt)*uy + Math.sin(tilt)*ny, Math.cos(tilt)*uz + Math.sin(tilt)*nz);
                pushLP(Math.cos(tilt)*ux - Math.sin(tilt)*nx, Math.cos(tilt)*uy - Math.sin(tilt)*ny, Math.cos(tilt)*uz - Math.sin(tilt)*nz);
            } else if (lpCount === 1) { pushLP(ux, uy, uz); }
        } else { pushLP(ux, uy, uz); }
    }

    // --- 2. [ä¿®æ­£] é¡è‰²åˆ¤å®šé‚è¼¯ (æ’é™¤ NO/NO2) ---
    
    // åˆ¤æ–·æ˜¯å¦ç‚ºæ°®æ°§åŒ–ç‰©ç‰¹ä¾‹
    let isNitrogenOxide = false;
    if (typeof currentKey !== 'undefined' && currentKey) {
        // åªè¦åˆ†å­åç¨±åŒ…å« NO æˆ– NO2 ä¸”ä¸å«é›»è·ç¬¦è™Ÿ(å¦‚ NO3-)ï¼Œå°±è¦–ç‚ºç‰¹ä¾‹
        if (currentKey === "NO" || currentKey === "NO2" || 
            currentKey.startsWith("NO|") || currentKey.startsWith("NO2|")) {
            isNitrogenOxide = true;
        }
    }

    // åªæœ‰ç•¶ï¼š
    // 1. å½¢å¼é›»è· <= -0.5 (å¸¶è² é›»)
    // 2. ä¸” ä¸æ˜¯é…ä½éµæ¥æ”¶è€…
    // 3. ä¸” ä¸æ˜¯ NO/NO2 é€™ç¨®ç‰¹ä¾‹
    // æ‰å°‡é›»å­å¡—æˆç²‰ç´…è‰²
    if (atom.formalCharge <= -0.5 && !atom.isCoordinateReceiver && !isNitrogenOxide) {
        let countToColor = Math.round(Math.abs(atom.formalCharge));
        
        // å€’è‘—æ‰¾ï¼ŒæŠŠæœ€å¾Œå¹¾é¡†é›»å­æ¨™è¨˜ç‚ºç²‰ç´…
        for (let i = dots.length - 1; i >= 0; i--) {
            if (countToColor > 0) {
                dots[i].isNegativeCharge = true;
                countToColor--;
            } else {
                break;
            }
        }
    }

    return dots;
}

function addPairToDots(dotsArray, atom, vector) {
    let lx = vector.x, ly = vector.y, lz = vector.z;
    let ox = -ly, oy = lx, oz = 0;
    if (Math.abs(lx) < 0.1 && Math.abs(ly) < 0.1) { ox = 1; oy = 0; oz = 0; }
    let oLen = Math.sqrt(ox*ox + oy*oy + oz*oz);
    const separation = 14.0; 
    ox = (ox/oLen) * (separation/2); oy = (oy/oLen) * (separation/2); oz = (oz/oLen) * (separation/2);
    const eRadius = 4.5;
    
    // é è¨­ isNegativeCharge ç‚º false
    dotsArray.push({ x: atom.x + lx + ox, y: atom.y + ly + oy, z: atom.z + lz + oz, isElectron: true, r: eRadius, type: 'electron', parentAtom: atom, isNegativeCharge: false });
    
    if (!atom.radical) {
        dotsArray.push({ x: atom.x + lx - ox, y: atom.y + ly - oy, z: atom.z + lz - oz, isElectron: true, r: eRadius, type: 'electron', parentAtom: atom, isNegativeCharge: false });
    }
}





// ==========================================
// ç‰¹æ®ŠåŠŸèƒ½ï¼šåŒ–å­¸åæ‡‰å‹•ç•« (V14.0 çµ‚æ¥µç‰ˆï¼šå…¨ä¸­æ–‡é‚è¼¯)
// ==========================================

// [æ–°å¢] è¼”åŠ©å‡½å¼ï¼šå–å¾—ç•¶å‰åˆ†å­çš„ä¸­æ–‡åç¨±
// é‚è¼¯ï¼šå¾ currentMolecule çš„ fullKey ä¸­æŠ“å– "|" å¾Œé¢çš„æ–‡å­—
function getCurrentMoleculeName() {
    if (!currentMolecule || !currentMolecule.fullKey) return "";
    const parts = currentMolecule.fullKey.split('|');
    // å¦‚æœæœ‰ '|' æŠ“ç¬¬äºŒæ®µ(ä¸­æ–‡)ï¼Œå¦å‰‡æŠ“ç¬¬ä¸€æ®µ
    return parts.length > 1 ? parts[1].trim() : parts[0].trim();
}

// --- æ ¸å¿ƒé‚è¼¯ï¼šæª¢æŸ¥æŒ‰éˆ•ç‹€æ…‹ & é‡ç½® ---
function checkReactionAvailable(key) {
    const btnContainer = document.getElementById("reaction-container");
    const resetBtn = document.querySelector(".reset-btn");
    const btns = document.querySelectorAll(".reaction-btn"); 
    
    // 1. åˆå§‹åŒ–ï¼šéš±è—æ‰€æœ‰æŒ‰éˆ•
    btns.forEach(b => b.style.display = "none");
    btnContainer.style.display = "none";
    resetBtn.style.display = "none";

    const currentName = getCurrentMoleculeName();

    // --- å„åˆ†å­å°ˆå±¬åæ‡‰æŒ‰éˆ• ---

    // A. ä¹™çƒ¯
    if (currentName === "ä¹™çƒ¯") {
        btnContainer.style.display = "block";
        document.getElementById("reaction-btn").style.display = "flex";
        document.getElementById("reaction-h2-btn").style.display = "flex";
        document.getElementById("reaction-hcl-btn").style.display = "flex";
        document.getElementById("reaction-cl2-btn").style.display = "flex";
        document.getElementById("reaction-kmno4-btn").style.display = "flex";
    } 
    // B. ä¸™çƒ¯
    else if (currentName === "ä¸™çƒ¯") { 
        btnContainer.style.display = "block";
        document.getElementById("reaction-propene-h2-btn").style.display = "flex";
        document.getElementById("reaction-propene-cl2-btn").style.display = "flex";
        document.getElementById("reaction-propene-hcl-btn").style.display = "flex";
        document.getElementById("reaction-propene-h2o-btn").style.display = "flex";
    } 
    // C. ä¹™ç‚”
    else if (currentName === "ä¹™ç‚”") {
        btnContainer.style.display = "block";
        document.getElementById("btn-c2h2-h2-full").style.display = "flex";
        document.getElementById("btn-c2h2-h2-part").style.display = "flex";
        document.getElementById("btn-c2h2-cl2-full").style.display = "flex";
        document.getElementById("btn-c2h2-cl2-part").style.display = "flex";
        document.getElementById("btn-c2h2-hcl-full").style.display = "flex";
        document.getElementById("btn-c2h2-hcl-part").style.display = "flex";
        document.getElementById("btn-c2h2-h2o").style.display = "flex";
    }
    // D. ç”²çƒ·
    else if (currentName === "ç”²çƒ·") {
        btnContainer.style.display = "block";
        const subBtn = document.getElementById("reaction-sub-btn");
        if(subBtn) subBtn.style.display = "flex"; 
        const nitroBtn = document.getElementById("reaction-nitro-btn");
        if(nitroBtn) nitroBtn.style.display = "flex"; 
    } 
    // E. ä¹™é†‡/ä¹™é†›/ä¹™é…¸
    else if (currentName === "ä¹™é†‡" || currentName === "é…’ç²¾") {
        btnContainer.style.display = "block";
        document.getElementById("reaction-ox-btn").style.display = "flex";
        document.getElementById("reaction-kmno4-btn").style.display = "flex";
    }
    else if (currentName === "ä¹™é†›") {
        btnContainer.style.display = "block";
        document.getElementById("reaction-ox-btn").style.display = "flex";
        document.getElementById("reaction-red-btn").style.display = "flex";
    }
    else if (currentName === "ä¹™é…¸" || currentName === "é†‹é…¸") {
        btnContainer.style.display = "block";
        // ä¹™é…¸é€šå¸¸æ˜¯çµ‚é»ï¼Œåªæœ‰é‡ç½®æŒ‰éˆ•
    }

    // --- [ä¿®æ­£] é‡ç½®æŒ‰éˆ•é¡¯ç¤ºé‚è¼¯ ---
    // åªè¦æ­·å²ç´€éŒ„ä¸æ˜¯ç©ºçš„ï¼Œå°±é¡¯ç¤ºé‡ç½®æŒ‰éˆ• (ä»£è¡¨å¯ä»¥"å›åˆ°ä¸Šä¸€é ")
    if (moleculeHistory.length > 0) {
        btnContainer.style.display = "block"; // ç¢ºä¿å®¹å™¨å¯è¦‹
        resetBtn.style.display = "block";     // é¡¯ç¤ºé‡ç½®æŒ‰éˆ•
    }
}


function resetReaction() {
    // [ä¿®æ­£] æ­·å²ç´€éŒ„é‚è¼¯
    // å¦‚æœæ²’æœ‰æ­·å²ç´€éŒ„ (é™£åˆ—ç‚ºç©º)ï¼Œä»£è¡¨å·²ç¶“æ˜¯æœ€æºé ­ï¼ŒæŒ‰ä¸‹ä¸åæ‡‰
    if (moleculeHistory.length === 0) return;

    isReactionRunning = false;
    isReactionFinished = false; 
    
    // éš±è—èªªæ˜æ–‡å­—
    const subEl = document.getElementById("viewport-subtitle");
    if(subEl) subEl.style.display = 'none';

    // å–å‡ºæœ€å¾Œä¸€ç­†ç´€éŒ„ (Pop)
    const previousState = moleculeHistory.pop();

    // è¼‰å…¥ä¸Šä¸€å€‹åˆ†å­
    // æ³¨æ„ï¼šé€™è£¡ä¸éœ€è¦å†æ ¹æ“šåç¨±åˆ¤æ–·äº†ï¼Œå› ç‚º previousState è£¡é¢å­˜çš„å°±æ˜¯æ­£ç¢ºçš„ä¾†æº
    loadMolecule(previousState.key, previousState.variant);
}

function finishReaction(nextKey, nextTitle, variantName = null, description = null) {
    // [æ–°å¢] å°‡ç•¶å‰çš„åˆ†å­ç‹€æ…‹å­˜å…¥æ­·å²ç´€éŒ„ (æ¨å…¥å †ç–Š)
    // é€™æ¨£ä¸ç®¡å¾ä¹™çƒ¯ä¾†é‚„æ˜¯ä¹™ç‚”ä¾†ï¼Œç³»çµ±éƒ½æœƒè¨˜å¾—ã€Œä¸Šä¸€å€‹æ˜¯èª°ã€
    moleculeHistory.push({
        key: currentKey,
        variant: currentVariantKey
    });

    const svg = document.getElementById("scene-root");
    svg.classList.add("scene-blur-out");
    
    setTimeout(() => {
        loadMolecule(nextKey, variantName); 
        
        if (description) {
            const subtitle = document.getElementById("viewport-subtitle");
            if (subtitle) {
                subtitle.textContent = description;
                subtitle.style.display = "block"; 
                subtitle.style.width = "fit-content";
                const themeColor = "#fb923c"; 
                subtitle.style.border = `1px solid ${themeColor}`;   
                subtitle.style.backgroundColor = "rgba(0, 0, 0, 0.6)"; 
                subtitle.style.borderRadius = "12px";                
                subtitle.style.padding = "10px 14px";                
                subtitle.style.backdropFilter = "blur(4px)";         
                subtitle.style.boxShadow = "0 4px 15px rgba(0,0,0,0.5)"; 
                subtitle.style.color = themeColor;                   
                subtitle.style.fontSize = "1.0rem"; 
                subtitle.style.fontWeight = "600";                   
                subtitle.style.textShadow = "0 2px 4px #000000";     
                subtitle.style.maxWidth = "20em"; 
                subtitle.style.whiteSpace = "normal";                
                subtitle.style.wordBreak = "break-word";             
                subtitle.style.lineHeight = "1.5";  
                subtitle.style.marginTop = "15px";
                subtitle.style.clear = "both";
                subtitle.style.textAlign = "left"; 
            }

            const kCard = document.getElementById("knowledge-card");
            const kText = document.getElementById("knowledge-text");
            if (kCard && kText) {
                kText.innerHTML = `<span style="color:#38bdf8; font-weight:bold;">[åæ‡‰ç™¼ç”Ÿ]</span> ${description}`;
                kCard.style.display = "block";
                kCard.classList.add("expanded");
            }
        }
        
        svg.classList.remove("scene-blur-out");
        svg.classList.add("scene-blur-in");
        
        setTimeout(() => {
            svg.classList.remove("scene-blur-in");
            isReactionRunning = false; 
            isReactionFinished = true; 
            checkReactionAvailable(nextKey); 
        }, 1500);
    }, 1500);
}

// 1. ä¹™çƒ¯ç³»åˆ— (åŸæ–™: ä¹™çƒ¯)
function runEthyleneHydration() {
    finishReaction("C2H5OH", "ä¹™é†‡", null, "ä¹™çƒ¯çš„ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œä¸€å€‹CåŸå­æ¥Hï¼Œå¦ä¸€å€‹CåŸå­æ¥OHï¼Œè½‰è®Šæˆä¹™é†‡");
}
function runEthyleneChlorination() {
    finishReaction("C2H4Cl2", "1,2-äºŒæ°¯ä¹™çƒ·", "C2H4Cl2|1,2-äºŒæ°¯ä¹™çƒ·", "ä¹™çƒ¯çš„ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œå…©å€‹CåŸå­å„æ¥1å€‹Clï¼Œè½‰è®Šæˆ1,2-äºŒæ°¯ä¹™çƒ·ï¼Œäº¦ç‚ºæ°§åŒ–åæ‡‰(Cæ°§åŒ–æ•¸ä¸Šå‡)");
}
function runEthyleneHydrogenation() {
    finishReaction("C2H6", "ä¹™çƒ·", null, "ä¹™çƒ¯çš„ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œå…©å€‹CåŸå­å„æ¥1å€‹Hï¼Œè½‰è®Šæˆä¹™çƒ·ï¼Œäº¦ç‚ºé‚„åŸåæ‡‰(Cæ°§åŒ–æ•¸ä¸‹é™)");
}
function runEthyleneHydrohalogenation() {
    finishReaction("C2H5Cl", "æ°¯ä¹™çƒ·", null, "ä¹™çƒ¯çš„ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œä¸€å€‹CåŸå­æ¥Hï¼Œå¦ä¸€å€‹CåŸå­æ¥Clï¼Œè½‰è®Šæˆæ°¯ä¹™çƒ·");
}
function runEthyleneOxidation() {
    finishReaction("C2H4(OH)2", "ä¹™äºŒé†‡", "C2H4(OH)2|ä¹™äºŒé†‡|1,2-ä¹™äºŒé†‡", "ä¹™çƒ¯é€šå…¥å†·ç¨€ã€ä¸­æ€§æˆ–å¾®é¹¼æ€§çš„ééŒ³é…¸é‰€æº¶æ¶²ä¸­ï¼Œç¢³ç¢³é›™éµæ–·è£‚ï¼Œç™¼ç”Ÿæ°§åŒ–åæ‡‰ï¼Œé›™éµçš„å…©å€‹Cæ¥ä¸ŠOHï¼Œç”Ÿæˆä¹™äºŒé†‡ã€‚");
}

// 2. ç”²çƒ·ç³»åˆ— (åŸæ–™: ç”²çƒ·)
function runMethaneSubstitution() {
    finishReaction("CH3Cl", "ä¸€æ°¯ç”²çƒ·", null, "ç”²çƒ·å…¶ä¸­ä¸€å€‹C-Héµæ–·è£‚ï¼Œæ¥ä¸ŠClåŸå­ï¼Œè„«å»çš„Hèˆ‡å¦ä¸€å€‹ClåŸå­çµåˆæˆHCl");
}

function runMethaneNitration() {
    finishReaction("CH3NO2", "ç¡åŸºç”²çƒ·", null, "ç”²çƒ·å…¶ä¸­ä¸€å€‹C-Héµæ–·è£‚ï¼Œæ¥ä¸ŠNOâ‚‚ï¼Œè„«å»çš„Hèˆ‡ç¡é…¸è„«å»çš„OHçµåˆæˆHâ‚‚O");
}

// --- 3. ä¸™çƒ¯ç³»åˆ— (åŸæ–™: ä¸™çƒ¯) ---
function runPropeneHydrogenation() {
    finishReaction("C3H8", "ä¸™çƒ·", null, "ä¸™çƒ¯çš„ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œå…©å€‹æ–·ğ¿éµçš„CåŸå­å„æ¥1å€‹Hï¼Œè½‰è®Šæˆä¸™çƒ·ï¼Œäº¦ç‚ºé‚„åŸåæ‡‰(Cæ°§åŒ–æ•¸ä¸‹é™)");
}

function runPropeneChlorination() {
    finishReaction("C3H6Cl2", "1,2-äºŒæ°¯ä¸™çƒ·", "C3H6Cl2|1,2-äºŒæ°¯ä¸™çƒ·", "ä¸™çƒ¯çš„ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œå…©å€‹æ–·ğ¿éµçš„CåŸå­å„æ¥1å€‹Clï¼Œè½‰è®Šæˆ1,2-äºŒæ°¯ä¸™çƒ·ï¼Œäº¦ç‚ºæ°§åŒ–åæ‡‰(Cæ°§åŒ–æ•¸ä¸Šå‡)");
}

function runPropeneHydrohalogenation() {
    finishReaction("C3H7Cl", "2-æ°¯ä¸™çƒ·", "C3H7Cl|2-æ°¯ä¸™çƒ·", "ä¸™çƒ¯çš„ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œå…©å€‹æ–·ğ¿éµçš„CåŸå­ï¼Œå«Hè¼ƒå¤šçš„Cé€£æ¥Hï¼Œå¦ä¸€å€‹C(ä¸­é–“)é€£æ¥Clï¼Œè½‰è®Šæˆ2-æ°¯ä¸™çƒ·(éœ€è€ƒæ…®é¦¬æ°è¦å‰‡)");
}

function runPropeneHydration() {
    finishReaction("C3H8O", "2-ä¸™é†‡", "C3H8O|2-ä¸™é†‡", "ä¸™çƒ¯çš„ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œå…©å€‹æ–·ğ¿éµçš„CåŸå­ï¼Œå«Hè¼ƒå¤šçš„Cé€£æ¥Hï¼Œå¦ä¸€å€‹C(ä¸­é–“)é€£æ¥OHï¼Œè½‰è®Šæˆç•°ä¸™é†‡(éœ€è€ƒæ…®é¦¬æ°è¦å‰‡)");
}

// 4. ä¹™é†‡ç³»åˆ—
function runEthanolMildOxidation() {
    finishReaction("CH3CHO", "ä¹™é†›", null, "ä¹™é†‡ç‚º1ç´šé†‡ï¼Œæ¥Oçš„Cä¸Šå…·æœ‰Hï¼Œä¸€èˆ¬æ°§åŒ–åŠ‘æœƒå…ˆå°‡ä¹™é†‡æ°§åŒ–æˆä¹™é†›");
}

function runEthanolStrongOxidation() {
    finishReaction("CH3COOH", "ä¹™é…¸", null, "ä¹™é†‡ç‚º1ç´šé†‡ï¼Œæ¥Oçš„Cä¸Šå…·æœ‰Hï¼Œç”±æ–¼ééŒ³é…¸é‰€æ°§åŒ–åŠ›è¼ƒå¼·ï¼Œæ•…ä¹™é†‡ç›´æ¥æ°§åŒ–æˆä¹™é…¸");
}

function runAcetaldehydeOxidation() {
    finishReaction("CH3COOH", "ä¹™é…¸", null, "ä¹™é†›æ¥Oçš„Cä¸Šå…·æœ‰Hï¼Œç¶“éæ°§åŒ–å¯ä»¥å½¢æˆä¹™é…¸");
}

function runAcetaldehydeReduction() {
    finishReaction("C2H5OH", "ä¹™é†‡", null, "é†›é¡å¯ä»¥é‚„åŸï¼Œè®Šå›1ç´šé†‡ï¼Œä¹™é†›é‚„åŸå¾Œå½¢æˆä¹™é†‡");
}

// 5. ä¹™ç‚”ç³»åˆ—

function runAcetyleneFullHydrogenation() {
    finishReaction("C2H6", "ä¹™çƒ·", null, "ä¹™ç‚”çš„å…©å€‹ç¢³ç¢³ğ¿éµå…¨æ•¸æ‰“æ–·ï¼Œåƒéµå…©ç«¯çš„CåŸå­å„æ¥ä¸Š2å€‹Hï¼Œè½‰è®Šæˆé£½å’Œçš„ä¹™çƒ·ï¼Œäº¦ç‚ºé‚„åŸåæ‡‰(Cæ°§åŒ–æ•¸ä¸‹é™)ã€‚");
}

function runAcetylenePartialHydrogenation() {
    finishReaction("C2H4", "ä¹™çƒ¯", null, "ä¹™ç‚”çš„å…¶ä¸­ä¸€å€‹ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œåƒéµå…©ç«¯çš„CåŸå­å„æ¥ä¸Š1å€‹Hï¼Œè½‰è®Šæˆä¹™çƒ¯ï¼Œæ­¤ç‚ºæ§åˆ¶æ¢ä»¶ä¸‹çš„éƒ¨åˆ†é‚„åŸåæ‡‰(Cæ°§åŒ–æ•¸ä¸‹é™)ã€‚");
}

function runAcetyleneFullHalogenation() {
    finishReaction("C2H2Cl4", "1,1,1,2-å››æ°¯ä¹™çƒ·", "C2H2Cl4|1,1,2,2-å››æ°¯ä¹™çƒ·", "ä¹™ç‚”çš„å…©å€‹ç¢³ç¢³ğ¿éµå…¨æ•¸æ‰“æ–·ï¼Œåƒéµå…©ç«¯çš„CåŸå­å„æ¥ä¸Š2å€‹Clï¼Œè½‰è®Šæˆ1,1,2,2-å››æ°¯ä¹™çƒ·ï¼Œäº¦ç‚ºæ°§åŒ–åæ‡‰(Cæ°§åŒ–æ•¸ä¸Šå‡)ã€‚");
}

function runAcetylenePartialHalogenation() {
    finishReaction("C2H2Cl2", "å-1,2-äºŒæ°¯ä¹™çƒ¯", "C2H2Cl2|å-1,2-äºŒæ°¯ä¹™çƒ¯", "ä¹™ç‚”çš„å…¶ä¸­ä¸€å€‹ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œåƒéµå…©ç«¯çš„CåŸå­å„æ¥ä¸Š1å€‹Clï¼Œè½‰è®Šæˆ1,2-äºŒæ°¯ä¹™çƒ¯(å¾åæ‡‰æ©Ÿæ§‹å¯çŸ¥ä¸»ç”¢ç‰©ç‚ºåå¼)ã€‚");
}

function runAcetyleneFullHydrohalogenation() {
    finishReaction("C2H4Cl2", "1,1-äºŒæ°¯ä¹™çƒ·", "C2H4Cl2|1,1-äºŒæ°¯ä¹™çƒ·", "ä¹™ç‚”èˆ‡è¶³é‡é¹µåŒ–æ°«åæ‡‰ï¼Œå…©å€‹ç¢³ç¢³ğ¿éµå…¨æ•¸æ‰“æ–·ã€‚ä¾é¦¬æ°è¦å‰‡ï¼Œå…©å€‹ClåŸå­æœƒæ¥åœ¨åŒä¸€å€‹CåŸå­ä¸Šï¼Œè½‰è®Šæˆ1,1-äºŒæ°¯ä¹™çƒ·ã€‚");
}

// 6. é¹µåŒ–æ°«éƒ¨åˆ†åŠ æˆ (+HCl) -> æ°¯ä¹™çƒ¯
function runAcetylenePartialHydrohalogenation() {
    finishReaction("C2H3Cl", "æ°¯ä¹™çƒ¯", "C2H3Cl|æ°¯ä¹™çƒ¯", "ä¹™ç‚”çš„å…¶ä¸­ä¸€å€‹ç¢³ç¢³ğ¿éµæ‰“æ–·ï¼Œä¸€å€‹Cæ¥Hï¼Œå¦ä¸€å€‹Cæ¥Clï¼Œè½‰è®Šæˆæ°¯ä¹™çƒ¯ï¼Œæ­¤ç‚ºèšæ°¯ä¹™çƒ¯(PVC)çš„é‡è¦å–®é«”åŸæ–™ã€‚");
}

// 7. æ°´åŠ æˆ (+H2O) -> ä¹™é†›
function runAcetyleneHydration() {
    finishReaction("CH3CHO", "ä¹™é†›", null, "ä¹™ç‚”åœ¨ç¡«é…¸èˆ‡ç¡«é…¸æ±(HgSOâ‚„)å‚¬åŒ–ä¸‹èˆ‡æ°´åŠ æˆï¼Œğ¿éµæ–·è£‚å¾Œå…ˆå½¢æˆä¸ç©©å®šçš„ä¹™çƒ¯é†‡ï¼Œéš¨å³ç™¼ç”Ÿã€é†›é…®-çƒ¯é†‡äº’è®Šç•°æ§‹ã€ï¼Œæ°«åŸå­è½‰ç§»ï¼Œæœ€çµ‚è½‰è®Šæˆä¹™é†›ã€‚");
}


// ==========================================
// 3. æ ¸å¿ƒé‚è¼¯èˆ‡é¡¯ç¤ºæ›´æ–°
// ==========================================

let currentMolecule = null;
let currentMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
let rotVelocity = { x: 0, y: 0, z: 0 }; 
let panOffset = { x: 0, y: 0 }; 
let isLongPressActive = false;
let scale = 1.6; 
let isDragging = false; 
let lastMouse = { x: 0, y: 0 };
let currentMode = 2; 
let altKeyIsDown = false;
let currentKey = null; 
let currentVariantKey = null; 
let lastInteractTime = 0; 
let lastTouchDist = 0;
let lastTouchCenter = { x:0, y:0 };
let lastTouchAngle = 0; 

function toggleMode() {
    currentMode = (currentMode + 1) % 3; 
    const modes = ['å¹³ç§»', 'æ—‹è½‰', 'è¤‡åˆ'];
    const classes = ['mode-pan', 'mode-rotate', 'mode-composite'];
    modeToggleBtn.className = `control-button ${classes[currentMode]} active`;
    modeToggleBtn.innerHTML = `æ¨¡å¼: ${modes[currentMode]}`;
}

function formatFormula(str) {
    if (!str) return "";
    if (str.includes('<') && str.includes('>')) return str;

    let s = str;
    let chargePart = "";
    let mainPart = s;

    // [ä¿®æ”¹] æ™ºæ…§é›»è·åˆ¤æ–· + æ­£è² è™Ÿåˆ†é›¢æ¨™ç±¤
    
    // 1. å˜—è©¦æŠ“å–çµå°¾çš„ "æ•¸å­—+æ­£è² è™Ÿ" (ä¾‹å¦‚ 3-, 2+)
    let matchWithDigit = s.match(/(\d)([+-]+)$/);
    
    if (matchWithDigit) {
        let index = matchWithDigit.index;
        let charBefore = s[index - 1]; // æŠ“å–æ•¸å­—å‰çš„ä¸€å€‹å­—

        // A. å¦‚æœå‰ä¸€å€‹å­—æ˜¯ "æ•¸å­—" (ä¾‹å¦‚ PO43-) -> 3- æ˜¯é›»è·
        if (/\d/.test(charBefore)) {
            // å°‡ç¬¦è™ŸåŒ…åœ¨ span è£¡ï¼Œæ–¹ä¾¿å–®ç¨èª¿æ•´ CSS
            let num = matchWithDigit[1];
            let sign = matchWithDigit[2];
            chargePart = `<sup>${num}<span class="charge-sign">${sign}</span></sup>`;
            mainPart = s.substring(0, index);
        } 
        // B. å¦‚æœå‰ä¸€å€‹å­—æ˜¯ "å­—æ¯" (ä¾‹å¦‚ IO3-) -> 3 æ˜¯ä¸‹æ¨™ï¼Œåªæœ‰ - æ˜¯é›»è·
        else {
            let sign = matchWithDigit[2];
            chargePart = `<sup><span class="charge-sign">${sign}</span></sup>`;
            // é€™è£¡ä¿ç•™æ•¸å­—éƒ¨åˆ†ï¼Œè®“å®ƒæµåˆ°ä¸‹é¢è¢«è½‰æˆä¸‹æ¨™
            mainPart = s.substring(0, s.length - sign.length); 
        }
    } else {
        // 2. å¦‚æœæ²’æŠ“åˆ°æ•¸å­—é›»è·ï¼ŒæŠ“ç´”ç¬¦è™Ÿ (ä¾‹å¦‚ -, +)
        let matchSignOnly = s.match(/([+-]+)$/);
        if (matchSignOnly) {
            let sign = matchSignOnly[0];
            chargePart = `<sup><span class="charge-sign">${sign}</span></sup>`;
            mainPart = s.substring(0, matchSignOnly.index);
        }
    }

    // 3. è™•ç†å‰©ä¸‹éƒ¨åˆ†çš„ä¸‹æ¨™ (æ‰€æœ‰æ•¸å­—éƒ½è®Šä¸‹æ¨™)
    mainPart = mainPart.replace(/(\d+)/g, '<sub>$1</sub>');

    return mainPart + chargePart;
}

function handleLoadBtn() {
    let rawVal = document.getElementById("formula-input").value;
    if (!rawVal) return;

    // ========== éš±è—åŠŸèƒ½ï¼šæŸ¥è©¢ç€è¦½äººæ¬¡ ==========
    if (rawVal === "äººæ¬¡") {
        const subEl = document.getElementById("viewport-subtitle");
        if (subEl) {
            subEl.style.display = "block";
            subEl.style.width = "fit-content";
            subEl.style.border = "1px solid #10b981"; 
            subEl.style.backgroundColor = "rgba(0, 0, 0, 0.9)";
            subEl.style.color = "#10b981"; 
            subEl.style.boxShadow = "0 0 15px rgba(16, 185, 129, 0.3)";
            subEl.style.padding = "10px 20px";
            subEl.style.textAlign = "center";
            
            subEl.innerHTML = `<div style="margin-bottom:8px; font-size:0.9rem; color:#ccc; font-weight:bold;">ğŸ‘ï¸ æœ¬ç«™ç´¯ç©ç€è¦½äººæ¬¡</div>`;
            
            const newImg = new Image();
            newImg.src = `https://hits.sh/weiwei-molecular-lab.app.svg?label=Views&color=10b981&labelColor=2d3748&t=${new Date().getTime()}`;
            newImg.alt = "è¼‰å…¥ä¸­...";
            newImg.style.height = "28px";
            newImg.style.display = "block";
            newImg.style.margin = "0 auto";

            newImg.onerror = function() {
                subEl.innerHTML += `<div style="color:#f87171; font-size:0.8rem;">(é€£ç·šå¤±æ•—)</div>`;
            };
            subEl.appendChild(newImg);
            document.getElementById("formula-input").value = "";
        }
        return; 
    }
    // ===============================================

    // [æ–°å¢] æ‰‹å‹•æœå°‹æ™‚ï¼Œæ¸…ç©ºæ­·å²ç´€éŒ„
    moleculeHistory = [];

    let searchKey = rawVal.replace(/\s/g, '').toUpperCase();
    let target = MOLECULE_INDEX[searchKey];
    if (target) {
        loadMolecule(target.key, target.variant);
    } else if (MOLECULE_DB[rawVal]) {
        loadMolecule(rawVal);
    } else if (MOLECULE_DB[searchKey]) {
        loadMolecule(searchKey);
    } else {
        alert("è³‡æ–™åº«ä¸­æœªæ‰¾åˆ°è©²åˆ†å­: " + rawVal);
    }
}

function toggleKnowledge() {
    const card = document.getElementById('knowledge-card');
    if(!card) return;
    card.classList.toggle('expanded');
    const isMobileNow = window.innerWidth < 768;
    if (isMobileNow && card.classList.contains('expanded')) {
        setTimeout(() => {
            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }, 100);
        }
    }

function updateSuggestions() {
    const container = document.getElementById('suggestions-container');
    if(!container) return;
    
    container.innerHTML = '<div class="suggestion-label">ä½ å¯èƒ½é‚„æƒ³çœ‹ï¼š</div>';
    
    const allKeys = Object.keys(MOLECULE_DB);
    if(allKeys.length === 0) return;
    
    const picks = [];
    let safety = 0;
    
    // éš¨æ©ŸæŒ‘é¸ 4 å€‹ä¸é‡è¤‡ä¸”ä¸æ˜¯ç•¶å‰çš„åˆ†å­
    while(picks.length < 4 && picks.length < allKeys.length && safety < 100) {
        const r = allKeys[Math.floor(Math.random() * allKeys.length)];
        if(!picks.includes(r) && r !== currentKey) {
            picks.push(r);
        }
        safety++;
    }
    
    picks.forEach(key => {
        const tag = document.createElement('div');
        tag.className = 'suggestion-tag';
        
        // è™•ç†é¡¯ç¤ºåç¨± (æŠ“å– | å¾Œé¢çš„ä¸­æ–‡ï¼Œå¦‚æœå¤ªé•·å°±æˆªæ–·)
        const parts = key.split('|');
        let displayName = parts.length > 1 ? parts[parts.length-1] : parts[0];
        if(displayName.length > 8) displayName = displayName.substring(0, 6) + '..';
        
        tag.textContent = displayName;
        
        tag.addEventListener('click', (e) => {
            e.stopPropagation();
            
            // [é—œéµä¿®æ”¹] é»æ“Šå»ºè­°æ¨™ç±¤æ™‚ï¼Œè¦–ç‚ºæ–°çš„èµ·é»ï¼Œæ¸…ç©ºæ­·å²ç´€éŒ„
            moleculeHistory = []; 
            
            loadMolecule(key);
        });
        
        container.appendChild(tag);
    });
}

function multiplyMatrix(a, b) {
    const out = [];
    for (let i = 0; i < 3; i++) { 
        for (let j = 0; j < 3; j++) { 
            let sum = 0;
            for (let k = 0; k < 3; k++) sum += a[i * 3 + k] * b[k * 3 + j];
            out.push(sum);
        }
    }
    return out;
}

function normalizeMatrix(m) {
    let x = [m[0], m[3], m[6]], y = [m[1], m[4], m[7]];
    const lenX = Math.sqrt(x[0]*x[0] + x[1]*x[1] + x[2]*x[2]);
    x = x.map(v => v / lenX);
    const dot = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];
    y = [y[0]-x[0]*dot, y[1]-x[1]*dot, y[2]-x[2]*dot];
    const lenY = Math.sqrt(y[0]*y[0] + y[1]*y[1] + y[2]*y[2]);
    y = y.map(v => v / lenY);
    const z = [x[1]*y[2]-x[2]*y[1], x[2]*y[0]-x[0]*y[2], x[0]*y[1]-x[1]*y[0]];
    return [x[0], y[0], z[0], x[1], y[1], z[1], x[2], y[2], z[2]];
}

function applyRotation(dx, dy, dz) {
    const cx = Math.cos(dy), sx = Math.sin(dy);
    const rotX = [1,0,0, 0,cx,-sx, 0,sx,cx];
    const cy = Math.cos(dx), sy = Math.sin(dx);
    const rotY = [cy,0,sy, 0,1,0, -sy,0,cy];
    const cz = Math.cos(dz), sz = Math.sin(dz);
    const rotZ = [cz,-sz,0, sz,cz,0, 0,0,1];
    let rot = multiplyMatrix(rotY, multiplyMatrix(rotX, rotZ));
    currentMatrix = multiplyMatrix(rot, currentMatrix);
    currentMatrix = normalizeMatrix(currentMatrix);
}

const sceneRoot = document.getElementById("scene-root");
const viewport = document.getElementById("viewport");
const modeToggleBtn = document.getElementById("mode-toggle");
const variantSelector = document.getElementById("variant-selector");

window.onload = () => {
    if(Object.keys(MOLECULE_DB).length > 0) {
        loadMolecule("P4O6"); 
    }
    animate();
    setupInteractions();
};

function loadMolecule(key, variantKey = null) {
    const subEl = document.getElementById("viewport-subtitle");
    if(subEl) { subEl.style.display = 'none'; subEl.textContent = ""; }
    
    let targetData = MOLECULE_DB[key];
    if (!targetData && MOLECULE_INDEX[key.toUpperCase()]) {
        const idx = MOLECULE_INDEX[key.toUpperCase()];
        targetData = MOLECULE_DB[idx.key];
        key = idx.key; 
        if (!variantKey) variantKey = idx.variant;
    }
    if (!targetData) { console.error("Data missing for:", key); return; }
    
    if (!variantKey && currentKey === key && typeof currentVariantKey !== 'undefined' && currentVariantKey) {
        variantKey = currentVariantKey;
    }

    rotVelocity = { x: 0.004, y: 0.004, z: 0 }; 
    currentKey = key;
    
    let data = targetData;
    if (variantKey && data.variants && data.variants[variantKey]) {
        data = data.variants[variantKey];
    } else if (data.variants && !variantKey) {
        const firstKey = Object.keys(data.variants)[0];
        data = data.variants[firstKey];
        variantKey = firstKey;
    }
    currentVariantKey = variantKey;

    if (!data.bondsRaw) data.bondsRaw = []; 
    let processedBonds = JSON.parse(JSON.stringify(data.bondsRaw)); 
    let processedAtoms = JSON.parse(JSON.stringify(data.atomsRaw)); 

    const toggleOct = document.getElementById('toggle-octet');
    const isOctetMode = toggleOct ? toggleOct.checked : true;

    const expandableCenters = ['P', 'S', 'Cl', 'As', 'Se', 'Br', 'I', 'Xe', 'Sb', 'Te'];
    let keptDoubleBonds = 0;

    processedBonds.forEach(bond => {
        const idx1 = bond[0], idx2 = bond[1], type = bond[2];
        const a1 = processedAtoms[idx1], a2 = processedAtoms[idx2];
        let cIdx = -1, tIdx = -1;

        if (expandableCenters.includes(a1.elem) && a2.elem === 'O') { cIdx = idx1; tIdx = idx2; }
        else if (expandableCenters.includes(a2.elem) && a1.elem === 'O') { cIdx = idx2; tIdx = idx1; }

        if (cIdx !== -1) {
            if (isOctetMode) {
                if (type === 'double') {
                    const resonanceMols = ["SO2", "äºŒæ°§åŒ–ç¡«", "äºç¡«é…¸", "H2SO3", "SO3", "äºç¡«é…¸æ ¹", "HSO3"];
                    const isResonance = resonanceMols.some(n => currentKey.includes(n));

                    if (isResonance && keptDoubleBonds === 0) {
                        keptDoubleBonds++;
                    } else {
                        bond[2] = 'coordinate';
                        bond[0] = cIdx;
                        bond[1] = tIdx;
                    }
                }
            } else {
                if (type === 'coordinate') bond[2] = 'double';
            }
        }
    });

    let renderObjects = processAtomsData(processedAtoms, processedBonds, data.center);
    
    // UI æ¨™ç±¤åˆ‡æ›
    const isIonic = data.isIonic === true || data.center === "Ionic";
    
    // [ä¿®æ­£] å¦‚æœæ˜¯é›¢å­æ™¶é«”ï¼Œå¼·åˆ¶ç§»é™¤æ‰€æœ‰é›»å­é» (LP)
    if (isIonic) {
        renderObjects = renderObjects.filter(obj => obj.type !== 'electron');
    }

    currentMolecule = { ...data, renderObjects: renderObjects, bonds3D: processedBonds };

    const lblHybrid = document.getElementById("lbl-hybrid");
    const lblShape = document.getElementById("lbl-shape");
    const lblAngle = document.getElementById("lbl-angle");
    const lblBonds = document.getElementById("lbl-bonds");
    const lblMass = document.getElementById("lbl-mass");

    // [ä¿®æ”¹] æ¨™ç±¤é¡¯ç¤ºé‚è¼¯
    if (data.isMetal) {
        // é‡‘å±¬æ¨¡å¼
        if(lblHybrid) lblHybrid.textContent = "æ™¶é«”å †ç©";
        if(lblShape) lblShape.textContent = "ç©ºé–“åˆ©ç”¨ç‡"; // ä¿®æ­£ç‚ºç©ºé–“åˆ©ç”¨ç‡
        if(lblAngle) lblAngle.textContent = "é…ä½æ•¸";
        if(lblBonds) lblBonds.textContent = "é‚Šé•·é—œä¿‚";
        if(lblMass) lblMass.textContent = "åŸå­é‡";
    } else if (isIonic) {
        // é›¢å­æ™¶é«”æ¨¡å¼ (é¹½é¡)
        if(lblHybrid) lblHybrid.textContent = "æ™¶é«”å †ç©";
        if(lblShape) lblShape.textContent = "åŠå¾‘æ¯” (râº/râ»)";
        if(lblAngle) lblAngle.textContent = "é…ä½æ•¸";
        if(lblBonds) lblBonds.textContent = "é‚Šé•·é—œä¿‚";
        if(lblMass) lblMass.textContent = "å¼é‡";
    } else {
        // ä¸€èˆ¬åˆ†å­æ¨¡å¼
        if(lblHybrid) lblHybrid.textContent = "æ··æˆè»ŒåŸŸ";
        if(lblShape) lblShape.textContent = "å½¢ç‹€";
        if(lblAngle) lblAngle.textContent = "éµè§’";
        if(lblBonds) lblBonds.textContent = "éµçµçµ±è¨ˆ";
        if(lblMass) lblMass.textContent = "åˆ†å­é‡";
    }

    const formulaEl = document.getElementById('info-formula');
    const nameEl = document.getElementById('info-name');
    const keyParts = (data.fullKey || key).split('|');
    let formulaText = keyParts[0];
    let nameText = keyParts.length > 1 ? keyParts[1] : "";
    if(formulaEl) formulaEl.innerHTML = formatFormula(formulaText);
    if(nameEl) nameEl.textContent = nameText;

    const kCard = document.getElementById('knowledge-card');
    const kText = document.getElementById('knowledge-text');
    if (kCard && kText) {
        if (data.desc) {
            kText.innerHTML = data.desc; kCard.style.display = 'block';
            kCard.classList.toggle('expanded', window.innerWidth >= 768);
        } else { kCard.style.display = 'none'; }
    }
    updateSuggestions();

    document.getElementById("disp-formula").innerHTML = formatFormula(formulaText);
    document.getElementById("disp-center").textContent = nameText;
    document.getElementById("disp-hybrid").textContent = data.hybrid;
    document.getElementById("disp-shape").textContent = data.shape;
    document.getElementById("disp-angle").textContent = data.angle;
    document.getElementById("disp-mp").textContent = (data.mp && data.mp !== "-") ? `${data.mp} Â°C` : "ç„¡è³‡æ–™";
    document.getElementById("disp-bp").textContent = (data.bp && data.bp !== "-") ? `${data.bp} Â°C` : "ç„¡è³‡æ–™";
    
    const bondDisp = document.getElementById("disp-bonds");
    if(bondDisp) {
        if (isIonic) {
            bondDisp.innerHTML = data.edgeRelation || "a = 2(r<sub>+</sub> + r<sub>-</sub>)";
        } else {
            let sigma = 0, pi = 0, totalLP = 0;
            if (currentMolecule.bonds3D) currentMolecule.bonds3D.forEach(b => { 
                sigma++; if(b[2]==='double') pi++; if(b[2]==='triple') pi+=2; 
            });
            currentMolecule.renderObjects.forEach(obj => { if (obj.type === 'atom') totalLP += (obj.calculatedLP||0); });
            bondDisp.innerHTML = `&sigma;: ${sigma} &nbsp; &pi;: ${pi} &nbsp; LP: ${totalLP}`;
        }
    }
    
    let totalMass = 0;
    if (data.atomsRaw) {
        if (isIonic && key.includes("NaCl")) totalMass = 22.99 + 35.45; 
        else data.atomsRaw.forEach(a => { totalMass += (ELEMENT_PROPS[a.elem]?.mass || 0); });
    }
    document.getElementById("disp-mass").textContent = totalMass > 0 ? `${totalMass.toFixed(2)} g/mol` : "N/A";
    
    const subtitle = document.getElementById("viewport-subtitle");
    if(subtitle) subtitle.textContent = `${nameText} (${formulaText})`; 
    
    updateVariantUI(key, variantKey);
    checkReactionAvailable(key);
}

function processAtomsData(atomList, bondList, centerElem) {
    let processed = [];
    
    // 1. å»ºç«‹åŸå­åŸºæœ¬ç‰©ä»¶
    const atomObjects = atomList.map((a, index) => { 
        const props = ELEMENT_PROPS[a.elem] || { c3d: "#ccc", r3d: 20 };
        const finalRadius = (a.r !== undefined) ? a.r : props.r3d;
        return { ...a, color: props.c3d, r: finalRadius, type: 'atom', originalIndex: index };
    });

    // 2. è¨ˆç®—å±¬æ€§
    atomObjects.forEach((atomObj, idx) => {
        const calcLP = autoAssignLonePairs(atomObj, bondList, atomObjects);
        atomObj.calculatedLP = calcLP;
        
        let bondLines = 0;
        let isCoordinateReceiver = false; // [æ¨™è¨˜] æ˜¯å¦ç‚ºé…ä½éµçš„æ¥æ”¶ç«¯

        bondList.forEach(b => {
            if (b[0] === idx || b[1] === idx) {
                let type = b[2] || "single";
                
                // [é—œéµ] åˆ¤æ–·æ˜¯å¦ç‚ºé…ä½éµæ¥æ”¶ç«¯ (b[0] -> b[1])
                // è‹¥æˆ‘æ˜¯æ¥æ”¶ç«¯ (idx === b[1])ï¼Œæ¨™è¨˜èµ·ä¾†ï¼Œä½†éµæ•¸ç…§ç®— 1
                if (type === "coordinate" && b[1] === idx) {
                    isCoordinateReceiver = true;
                    bondLines += 1;
                } else if (type === "coordinate" && b[0] === idx) {
                    bondLines += 1; // æ–½äºˆç«¯ä¹Ÿç®— 1 æ ¹éµ
                } else {
                    // ä¸€èˆ¬å…±åƒ¹éµè¨ˆç®—
                    if (type.includes("triple")) bondLines += 3;
                    else if (type.includes("double")) bondLines += 2;
                    else bondLines += 1;
                }
            }
        });

        // å°‡æ¨™è¨˜å­˜å…¥ç‰©ä»¶ï¼Œçµ¦ generateElectronDots ä½¿ç”¨
        atomObj.isCoordinateReceiver = isCoordinateReceiver;

        const props = ELEMENT_PROPS[atomObj.elem];
        if (props) {
            const dots = (calcLP * 2) + (atomObj.radical ? 1 : 0);
            // æ­£å¸¸è¨ˆç®—å½¢å¼é›»è· (S->O çš„ O ç®—å‡ºä¾†æœƒæ˜¯ -1ï¼Œé€™æ˜¯å°çš„åŒ–å­¸å®šç¾©)
            atomObj.formalCharge = props.ve - dots - bondLines;
        } else {
            atomObj.formalCharge = 0;
        }
        
        processed.push(atomObj);
        
        if (ELEMENT_PROPS[atomObj.elem]) { 
            const electronDots = generateElectronDots(atomObj, idx, atomObjects, bondList);
            electronDots.forEach(dot => {
                processed.push(dot); 
            });
        }
    });
    return processed;
}

function updateVariantUI(key, activeVariant) {
    const rootData = MOLECULE_DB[key];
    variantSelector.innerHTML = ''; 
    
    // æ¸…é™¤æ‰€æœ‰èˆŠçš„ä¸»é¡Œ class
    variantSelector.classList.remove('acid-theme', 'resonance-theme', 'structure-theme');
    
    if (rootData.variants) {
        variantSelector.style.display = 'block';
        
        const variantKeys = Object.keys(rootData.variants);
        
        // --- 1. åˆ¤æ–·æ˜¯å¦ç‚ºã€Œå…±æŒ¯çµæ§‹ã€ (ç´«è‰²) ---
        const isResonance = variantKeys.some(vKey => vKey.includes("å…±æŒ¯") || vKey.includes("Resonance"));

        // --- 2. [æ–°å¢] åˆ¤æ–·æ˜¯å¦ç‚ºã€Œçµæ§‹/æ™¶é«”åˆ‡æ›ã€ (è—è‰²) ---
        // é‚è¼¯ï¼šè®Šé«”åç¨±ä¸­åŒ…å« "æ™¶é«”", "å †ç©", "Simple", "Crystal"
        const isStructure = variantKeys.some(vKey => vKey.includes("æ™¶é«”") || vKey.includes("å †ç©") || vKey.includes("Crystal"));

        // --- 3. åˆ¤æ–·æ˜¯å¦ç‚ºã€Œåˆ†å­/é›¢å­/é¹½é¡ã€ (æ©˜è‰²) ---
        const isAcidSaltSeries = key.includes("é…¸") || key.includes("Acid") || 
                                 key.includes("H2O") || key.includes("NH3") || 
                                 variantKeys.some(vKey => vKey.includes("æ ¹") || vKey.includes("é›¢å­") || vKey.includes("é¹½") || vKey.includes("Salt") || vKey.includes("Ion"));
        
        // --- 4. è¨­å®šæ¨™é¡Œèˆ‡ä¸»é¡Œè‰² ---
        const hdr = document.createElement('div');
        hdr.className = 'variant-header';

        if (isResonance) {
            variantSelector.classList.add('resonance-theme'); // ç´«è‰²
            hdr.textContent = 'é¸æ“‡å…±æŒ¯çµæ§‹ (Resonance):';
        } else if (isStructure) {
            variantSelector.classList.add('structure-theme'); // [æ–°å¢] è—è‰²
            hdr.textContent = 'é¸æ“‡çµæ§‹å±¤æ¬¡ (Structure):';
        } else if (isAcidSaltSeries) {
            variantSelector.classList.add('acid-theme'); // æ©˜è‰²
            hdr.textContent = 'é¸æ“‡è§£é›¢ç‹€æ…‹ (åˆ†å­/é›¢å­/é¹½é¡):';
        } else {
            // ç¶ è‰² (é è¨­)
            hdr.textContent = 'é¸æ“‡åŒåˆ†ç•°æ§‹ç‰©:';
        }
        
        variantSelector.appendChild(hdr);
        
        // --- 5. ç”¢ç”Ÿé¸é … ---
        for (let vKey in rootData.variants) {
            const div = document.createElement('div');
            div.className = 'variant-option';
            
            const radio = document.createElement('input');
            radio.type = 'radio'; radio.name = 'v';
            if (vKey === activeVariant) radio.checked = true;
            
            const span = document.createElement('span'); 
            
            const variantData = rootData.variants[vKey];
            const fullKeyString = variantData.fullKey || vKey;
            const parts = fullKeyString.split('|');
            
            // å„ªå…ˆé¡¯ç¤ºä¸­æ–‡åç¨±
            let labelText = "";
            if (parts.length > 1) {
                labelText = parts[1].trim();
                span.textContent = ` ${labelText}`; 
            } else {
                labelText = parts[0].trim();
                span.innerHTML = ` ${formatFormula(labelText)}`;
            }
            
            div.appendChild(radio); div.appendChild(span);
            div.addEventListener('click', () => loadMolecule(key, vKey));
            variantSelector.appendChild(div);
        }
    } else {
        variantSelector.style.display = 'none';
    }
}



// ==========================================
// 4. æ¸²æŸ“å¼•æ“
// ==========================================

function project(p) {
    const m = currentMatrix;
    let x3 = p.x * m[0] + p.y * m[1] + p.z * m[2];
    let y3 = p.x * m[3] + p.y * m[4] + p.z * m[5];
    let z3 = p.x * m[6] + p.y * m[7] + p.z * m[8];
    
    let s = (600 / (600 - Math.min(z3, 590))) * scale;
    return { x: x3 * s + panOffset.x, y: y3 * s + panOffset.y, z: z3, scale: s };
}

function renderScene(time = 0) {
    sceneRoot.innerHTML = "";
    if(!currentMolecule) return;
    
    // --- 1. å®šç¾©æ¿¾é¡èˆ‡æ¼¸å±¤ ---
    const defs = document.createElementNS("http://www.w3.org/2000/svg", "defs");
    // ç™¼å…‰æ¿¾é¡ (çµ¦é‚Šæ¡†ç”¨)
    const boxGlowFilter = document.createElementNS("http://www.w3.org/2000/svg", "filter");
    boxGlowFilter.setAttribute("id", "box-glow");
    boxGlowFilter.innerHTML = `<feGaussianBlur stdDeviation="1.5" result="coloredBlur"/><feMerge><feMergeNode in="coloredBlur"/><feMergeNode in="SourceGraphic"/></feMerge>`;
    defs.appendChild(boxGlowFilter);

    // åŸå­ç«‹é«”æ¼¸å±¤
    const usedColors = new Set();
    currentMolecule.renderObjects.forEach(obj => { if (obj.type === 'atom') usedColors.add(obj.color); });
    usedColors.forEach(color => {
        const cleanColor = color.replace('#','');
        const atomGrad = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
        atomGrad.setAttribute("id", `atom-grad-${cleanColor}`);
        atomGrad.setAttribute("cx", "35%"); atomGrad.setAttribute("cy", "35%"); atomGrad.setAttribute("r", "60%");
        let highlight = "#FFFFFF"; let baseColor = color; let shadowColor = adjustColor(color, -80); 
        atomGrad.innerHTML = `<stop offset="0%" stop-color="${highlight}" stop-opacity="0.95"/><stop offset="40%" stop-color="${baseColor}" stop-opacity="1"/><stop offset="100%" stop-color="${shadowColor}" stop-opacity="1"/>`;
        defs.appendChild(atomGrad);
    });
    
    // (ä¿ç•™åŸæœ¬çš„è»ŒåŸŸ/é»æ“Š/é›»è·å…‰æšˆå®šç¾©ï¼Œç‚ºç¯€çœç¯‡å¹…æ­¤è™•ä¸é‡è¤‡åˆ—å‡ºï¼Œè«‹ç¢ºä¿æ‚¨çš„æª”æ¡ˆä¸­æœ‰é€™äº›)
    const highlightGlowCenter = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    highlightGlowCenter.setAttribute("id", "highlight-glow-center");
    highlightGlowCenter.setAttribute("cx", "50%"); highlightGlowCenter.setAttribute("cy", "50%"); highlightGlowCenter.setAttribute("r", "50%");
    highlightGlowCenter.innerHTML = `<stop offset="0%" stop-color="#facc15" stop-opacity="0.6"/><stop offset="100%" stop-color="#facc15" stop-opacity="0"/>`;
    defs.appendChild(highlightGlowCenter);
    const highlightGlowNeighbor = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    highlightGlowNeighbor.setAttribute("id", "highlight-glow-neighbor");
    highlightGlowNeighbor.setAttribute("cx", "50%"); highlightGlowNeighbor.setAttribute("cy", "50%"); highlightGlowNeighbor.setAttribute("r", "50%");
    highlightGlowNeighbor.innerHTML = `<stop offset="0%" stop-color="#ffffff" stop-opacity="0.4"/><stop offset="100%" stop-color="#ffffff" stop-opacity="0"/>`;
    defs.appendChild(highlightGlowNeighbor);
    const chargeGlow = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    chargeGlow.setAttribute("id", "charge-glow-pink");
    chargeGlow.setAttribute("cx", "50%"); chargeGlow.setAttribute("cy", "50%"); chargeGlow.setAttribute("r", "50%");
    chargeGlow.innerHTML = `<stop offset="0%" stop-color="#ffffff" stop-opacity="1"/><stop offset="40%" stop-color="#f472b6" stop-opacity="0.9"/><stop offset="100%" stop-color="#ec4899" stop-opacity="0"/>`;
    defs.appendChild(chargeGlow);
    const orbGradP = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    orbGradP.setAttribute("id", "grad-orb-p");
    orbGradP.setAttribute("cx", "30%"); orbGradP.setAttribute("cy", "30%"); orbGradP.setAttribute("r", "80%");
    orbGradP.innerHTML = `<stop offset="0%" stop-color="#34D399" stop-opacity="0.95"/><stop offset="60%" stop-color="#059669" stop-opacity="0.9"/><stop offset="100%" stop-color="#064E3B" stop-opacity="0.9"/>`;
    defs.appendChild(orbGradP);
    const orbGradD = document.createElementNS("http://www.w3.org/2000/svg", "radialGradient");
    orbGradD.setAttribute("id", "grad-orb-d");
    orbGradD.setAttribute("cx", "30%"); orbGradD.setAttribute("cy", "30%"); orbGradD.setAttribute("r", "80%");
    orbGradD.innerHTML = `<stop offset="0%" stop-color="#FBBF24" stop-opacity="0.95"/><stop offset="60%" stop-color="#D97706" stop-opacity="0.9"/><stop offset="100%" stop-color="#78350F" stop-opacity="0.9"/>`;
    defs.appendChild(orbGradD);

    sceneRoot.appendChild(defs);

    // --- 2. æŠ•å½±èˆ‡ç‰©ä»¶æ”¶é›† ---
    const showLPs = document.getElementById('toggle-lp') ? document.getElementById('toggle-lp').checked : true;
    const isAnyHighlighted = currentMolecule.renderObjects.some(o => o.isHighlighted);
    const renderList = [];
    
    // å»ºç«‹åŸå­ç´¢å¼•å°ç…§è¡¨èˆ‡ä½ç½®æ¸…å–®
    const atomMap = new Map();
    const atomPosList = [];

    currentMolecule.renderObjects.forEach((obj, i) => {
        if (obj.isLobe) {
            const pStart = project(obj); const pEnd = project(obj.end);
            renderList.push({ type: 'lobe', z: (pStart.z + pEnd.z)/2, pStart, pEnd, colorType: obj.colorType, scale: pStart.scale });
            return;
        }
        if (obj.isAxis) {
            const pStart = project(obj); const pEnd = project(obj.end);
            renderList.push({ type: 'axisVector', z: (pStart.z + pEnd.z)/2, pStart, pEnd, label: obj.label, scale: pStart.scale });
            return;
        }
        if (obj.type === 'electron' && !showLPs) return;

        const p = project(obj);
        let alpha = 1.0;
        if (isAnyHighlighted) {
            if (obj.type === 'atom') alpha = obj.isHighlighted ? 1.0 : 0.1;
            else if (obj.type === 'electron') alpha = obj.parentAtom && obj.parentAtom.isHighlighted ? 1.0 : 0.1;
        }

        const renderObj = { ...obj, px: p.x, py: p.y, pz: p.z, scale: p.scale, idx: i, alpha: alpha, z: p.z };
        renderList.push(renderObj);

        if (obj.type === 'atom') {
            atomMap.set(obj.originalIndex, renderObj);
            atomPosList.push({ x: obj.x, y: obj.y, z: obj.z, r: obj.r });
        }
    });

    // --- 3. è™•ç†æ™¶é«”é‚Šæ¡† (Box Lines) ---
    if (currentMolecule.extraLines) {
        currentMolecule.extraLines.forEach(line => {
            const pStart = project(line.start);
            const pEnd = project(line.end);
            const avgZ = (pStart.z + pEnd.z) / 2;
            let alpha = isAnyHighlighted ? 0.1 : 1.0;

            // å°‹æ‰¾ç«¯é»æ˜¯å¦æœ‰åŸå­
            const findAtomR = (pt) => {
                const match = atomPosList.find(a => Math.abs(a.x - pt.x) < 2 && Math.abs(a.y - pt.y) < 2 && Math.abs(a.z - pt.z) < 2);
                return match ? match.r : 0;
            };

            const rStart = findAtomR(line.start);
            const rEnd = findAtomR(line.end);

            renderList.push({
                type: "boxLine", z: avgZ,
                x1: pStart.x, y1: pStart.y,
                x2: pEnd.x,   y2: pEnd.y,
                scale: (pStart.scale + pEnd.scale) / 2,
                r1: rStart, r2: rEnd, 
                alpha: alpha
            });
        });
    }

    // --- 4. éµçµç”Ÿæˆ ---
    if (currentMolecule.bonds3D) {
        currentMolecule.bonds3D.forEach((bond, index) => { 
            const idx1 = bond[0]; const idx2 = bond[1];
            const a1 = atomMap.get(idx1); const a2 = atomMap.get(idx2);
            if (!a1 || !a2) return; 

            let drawStyle = bond[2] || "single";
            let bondAlpha = 1.0;
            if (isAnyHighlighted) {
                const connectedToCenter = (a1.isHighlighted==='center' && a2.isHighlighted==='neighbor') || (a2.isHighlighted==='center' && a1.isHighlighted==='neighbor');
                if (!connectedToCenter) bondAlpha = 0.05;
            }

            renderList.push({ 
                type: "bond", z: (a1.pz + a2.pz) / 2, 
                x1: a1.px, y1: a1.py, x2: a2.px, y2: a2.py, 
                r1: a1.r * a1.scale, r2: a2.r * a2.scale,
                style: drawStyle, scale: (a1.scale + a2.scale) / 2, 
                c1: a1.color, c2: a2.color, bondIdx: index,
                opacity: 1, alpha: bondAlpha 
            });
        });
    }

    // --- 5. æ’åºä¸¦ç¹ªè£½ ---
    // [ä¿®æ­£é‡é»] Zè»¸æ’åºé‚è¼¯ï¼šå¦‚æœ Z å·®ä¸å¤š (åœ¨èª¤å·®ç¯„åœå…§)ï¼Œå¼·åˆ¶è®“ boxLine æ’åœ¨å‰é¢ (ä¹Ÿå°±æ˜¯å…ˆç•«ï¼Œè¢«å¾Œé¢çš„è“‹ä½)
    renderList.sort((a,b) => {
        const delta = a.z - b.z;
        if (Math.abs(delta) < 5) { // æ·±åº¦éå¸¸æ¥è¿‘
            if (a.type === 'boxLine' && b.type === 'atom') return -1; // ç·šåœ¨åŸå­å‰ -> å…ˆç•«ç·š -> åŸå­è“‹ä½ç·š
            if (a.type === 'atom' && b.type === 'boxLine') return 1;
        }
        return delta;
    }).forEach(obj => {
        if (obj.type === "bond") drawBond(obj);
        else if (obj.type === "atom") drawAtom(obj);
        else if (obj.type === "lobe") drawLobe(obj);
        else if (obj.type === "axisVector") drawAxisVector(obj);
        else if (obj.type === "electron") drawElectron(obj);
        else if (obj.type === "boxLine") drawBoxLine(obj);
    });
}

function drawBoxLine(l) {
    let x1 = l.x1, y1 = l.y1, x2 = l.x2, y2 = l.y2;
    
    const dx = x2 - x1;
    const dy = y2 - y1;
    const len = Math.sqrt(dx*dx + dy*dy);
    
    if (len > 0) {
        const nx = dx / len;
        const ny = dy / len;

        // æˆªæ–·é‚è¼¯
        const cut1 = (l.r1 || 0) * l.scale * 0.95;
        const cut2 = (l.r2 || 0) * l.scale * 0.95;

        if (len > (cut1 + cut2)) {
            x1 = x1 + nx * cut1;
            y1 = y1 + ny * cut1;
            x2 = x2 - nx * cut2;
            y2 = y2 - ny * cut2;
        } else {
            return;
        }
    }

    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", x1); line.setAttribute("y1", y1);
    line.setAttribute("x2", x2); line.setAttribute("y2", y2);
    
    // [è¨­å®šï¼šç™½è‰²ç²—æ¡†]
    line.setAttribute("stroke", "#ffffff"); 
    line.setAttribute("stroke-width", "5"); 
    line.setAttribute("stroke-linecap", "round");
    
    if (!isMobile) {
        line.setAttribute("filter", "url(#box-glow)"); 
    }
    
    line.setAttribute("opacity", l.alpha === 0.1 ? "0.1" : "0.9"); 
    
    sceneRoot.appendChild(line);
}

// 2. ç¹ªè£½åŸå­é€£ç·š (ç´°ç™½ç·š + æˆªæ–·)
function drawBond(b) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");

    // ============================================================
    // [å€å¡Š 1] NaCl / é›¢å­æ™¶é«”å°ˆç”¨ç¹ªåœ–é‚è¼¯ (å¤–é‡‘å±¬æ¡† + å…§ç™¼å…‰ç´°ç·š)
    // ============================================================
    if (b.style === "ionic_thick" || b.style === "ionic_thin") {
        const dx = b.x2 - b.x1, dy = b.y2 - b.y1, len = Math.sqrt(dx*dx + dy*dy);
        if(len === 0) return;
        
        // è¨ˆç®—æˆªæ–·é»ï¼Œè®“ç·šæ¢è²¼é½ŠåŸå­è¡¨é¢
        const nx = dx / len, ny = dy / len;
        const off1 = b.r1 * 0.9, off2 = b.r2 * 0.9; 
        
        if (len > (off1 + off2)) {
            const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
            l.setAttribute("x1", b.x1 + nx * off1);
            l.setAttribute("y1", b.y1 + ny * off1);
            l.setAttribute("x2", b.x2 - nx * off2);
            l.setAttribute("y2", b.y2 - ny * off2);
            
            // 1. è‡ªå‹•æ³¨å…¥ã€Œé«˜è³ªæ„Ÿé‡‘å±¬æ¼¸å±¤ã€ (å¦‚æœé‚„æ²’å»ºç«‹é)
            const gradID = "grad-hyper-metal";
            if (!document.getElementById(gradID)) {
                const defs = document.querySelector("defs") || sceneRoot;
                const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
                grad.setAttribute("id", gradID);
                grad.setAttribute("x1", "0%"); grad.setAttribute("y1", "0%");
                grad.setAttribute("x2", "100%"); grad.setAttribute("y2", "0%"); 
                grad.innerHTML = `
                    <stop offset="0%" stop-color="#475569"/>
                    <stop offset="30%" stop-color="#cbd5e1"/>
                    <stop offset="50%" stop-color="#ffffff"/>
                    <stop offset="70%" stop-color="#cbd5e1"/>
                    <stop offset="100%" stop-color="#475569"/>
                `;
                defs.appendChild(grad);
            }

            // 2. æ¨£å¼èˆ‡æ¿¾é¡è¨­å®š
            let baseOpacity = 1.0;

            if (b.style === "ionic_thick") {
                // --- å¤–æ¡† (ç²—é‡‘å±¬) ---
                l.setAttribute("stroke", `url(#${gradID})`); 
                l.setAttribute("stroke-width", 12 * b.scale); 
                baseOpacity = 1.0; 
            } else {
                // --- å…§éƒ¨ (æœ¦æœ§ç™¼å…‰ç·š) ---
                l.setAttribute("stroke", "#ffffff");      
                l.setAttribute("stroke-width", 4.0 * b.scale); 
                
                // [é—œéµä¿®æ”¹] ç§»é™¤ !isMobile åˆ¤æ–·ï¼Œå¼·åˆ¶æ‰€æœ‰è£ç½®éƒ½å¥—ç”¨ç™¼å…‰æ¿¾é¡
                // é€™æ¨£æ‰‹æ©Ÿç‰ˆä¹Ÿèƒ½çœ‹åˆ°æ¼‚äº®çš„ç™¼å…‰æ•ˆæœ
                l.setAttribute("filter", "url(#soft-glow)");

                baseOpacity = 0.6; // åŠé€æ˜
            }
            l.setAttribute("stroke-linecap", "round");

            // 3. äº’å‹•é‚è¼¯ (é»æ“Šä¸­å¿ƒæ™‚çš„æ·¡å‡ºæ•ˆæœ)
            let finalOpacity = baseOpacity; 
            if (b.alpha < 0.9) {
                finalOpacity = 0.05; 
            }
            l.setAttribute("opacity", finalOpacity);

            g.appendChild(l);
        }
        sceneRoot.appendChild(g);
        return; // æ™¶é«”ç¹ªè£½å®Œç•¢ï¼Œç›´æ¥è¿”å›
    }

    // ============================================================
    // [å€å¡Š 2] ä¸€èˆ¬å…±åƒ¹éµèˆ‡èˆŠç‰ˆé‡‘å±¬ (ä¿æŒåŸæ¨£ä¸å‹•)
    // ============================================================
    
    // æ‡‰ç”¨é€æ˜åº¦ (å…±ç”¨)
    if (b.alpha < 1.0) g.setAttribute("opacity", b.alpha);

    // A. èˆŠç‰ˆé‡‘å±¬/ç°¡å–®é›¢å­æ™¶é«”é‚è¼¯
    if (currentMolecule && (currentMolecule.isMetal || (currentMolecule.isIonic && !b.style))) {
        const dx = b.x2 - b.x1;
        const dy = b.y2 - b.y1;
        const len = Math.sqrt(dx*dx + dy*dy);
        if(len > 0) { // åŸæœ¬é‚è¼¯æœ‰åš len > 0 åˆ¤æ–·ï¼Œé€™è£¡æ•´åˆ
            const nx = dx / len;
            const ny = dy / len;
            // é€™è£¡ä½¿ç”¨ 0.95 çš„æˆªæ–·ä¿‚æ•¸ï¼Œèˆ‡ä¸Šé¢æ™¶é«”ä¸åŒï¼Œä¿æŒåŸæ¨£
            const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
            l.setAttribute("x1", b.x1 + nx * b.r1 * 0.95); 
            l.setAttribute("y1", b.y1 + ny * b.r1 * 0.95);
            l.setAttribute("x2", b.x2 - nx * b.r2 * 0.95); 
            l.setAttribute("y2", b.y2 - ny * b.r2 * 0.95);
            l.setAttribute("stroke", "#9ca3af"); 
            l.setAttribute("stroke-width", "4"); 
            l.setAttribute("stroke-linecap", "round");
            l.setAttribute("opacity", b.alpha < 1.0 ? 0.05 : 0.6); 
            g.appendChild(l);
        }
        sceneRoot.appendChild(g);
        return; 
    }

    // B. ä¸€èˆ¬å…±åƒ¹éµ (æ¼¸å±¤ã€å¤šé‡éµ)
    const dxMol = b.x2-b.x1, dyMol = b.y2-b.y1, lenMol = Math.sqrt(dxMol*dxMol+dyMol*dyMol);
    if(lenMol === 0) return;
    const nxMol = dxMol/lenMol, nyMol = dyMol/lenMol;
    const px = -nyMol, py = nxMol;
    const w = 16 * b.scale; const strokeW = w * 0.45; const shorten = 0.75;      
    const x1 = b.x1 + nxMol * b.r1 * shorten; const y1 = b.y1 + nyMol * b.r1 * shorten;
    const x2 = b.x2 - nxMol * b.r2 * shorten; const y2 = b.y2 - nyMol * b.r2 * shorten;
    
    let strokeColor;
    if (b.style === "coordinate") strokeColor = b.c1; 
    else {
        const gradId = `bond-grad-${b.bondIdx}`;
        const defs = sceneRoot.querySelector("defs");
        const grad = document.createElementNS("http://www.w3.org/2000/svg", "linearGradient");
        grad.setAttribute("id", gradId); grad.setAttribute("gradientUnits", "userSpaceOnUse");
        grad.setAttribute("x1", x1); grad.setAttribute("y1", y1); grad.setAttribute("x2", x2); grad.setAttribute("y2", y2);
        grad.innerHTML = `<stop offset="0%" stop-color="${b.c1}"/><stop offset="40%" stop-color="${b.c1}"/><stop offset="60%" stop-color="${b.c2}"/><stop offset="100%" stop-color="${b.c2}"/>`;
        defs.appendChild(grad);
        strokeColor = `url(#${gradId})`;
    }
    
    const drawLine = (ox, oy, width, color, opacity=1) => {
        const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
        l.setAttribute("x1", x1+ox); l.setAttribute("y1", y1+oy); l.setAttribute("x2", x2+ox); l.setAttribute("y2", y2+oy);
        l.setAttribute("stroke", color); l.setAttribute("stroke-width", width); l.setAttribute("stroke-linecap", "round");
        const finalOp = opacity * (b.opacity || 1); 
        if(finalOp < 1) l.setAttribute("opacity", finalOp);
        return l;
    };
    const drawCylinder = (ox, oy) => {
        g.appendChild(drawLine(ox, oy, strokeW, strokeColor));
        g.appendChild(drawLine(ox, oy, strokeW * 0.25, "#ffffff", 0.5));
    };
    
    if (b.style === "double") { const off = w * 0.38; drawCylinder(px*off, py*off); drawCylinder(-px*off, -py*off); } 
    else if (b.style === "triple") { const off = w * 0.75; drawCylinder(0, 0); drawCylinder(px*off, py*off); drawCylinder(-px*off, -py*off); } 
    else if (b.style === "coordinate_triple") { const off = w * 0.75; drawCylinder(0, 0); drawCylinder(px*off, py*off); g.appendChild(drawLine(-px*off, -py*off, strokeW, strokeColor)); } 
    else { drawCylinder(0, 0); }
    
    sceneRoot.appendChild(g);
}

function drawAtom(a) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    g.setAttribute("data-atom-idx", a.idx); 
    
    if (a.alpha < 1.0) g.setAttribute("opacity", a.alpha);

    // é»æ“Šé«˜äº®
    if (a.isHighlighted) {
        const glowId = a.isHighlighted === "center" ? "highlight-glow-center" : "highlight-glow-neighbor";
        const halo = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        halo.setAttribute("cx", a.px); halo.setAttribute("cy", a.py);
        halo.setAttribute("r", a.r * a.scale * 2.5); 
        halo.setAttribute("fill", `url(#${glowId})`);
        g.appendChild(halo);
    }

    if (isPlasmaMode) {
        // [ä¿®æ­£] æ‰‹æ©Ÿç‰ˆé›»æ¼¿ä¿®å¾©ï¼šå¼·åˆ¶ä½¿ç”¨æ¨™æº–æ¿¾é¡
        g.setAttribute("style", "mix-blend-mode: screen;"); 
        const baseR = a.r * a.scale;
        
        // æ ¸å¿ƒ
        const gasCloud = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        gasCloud.setAttribute("cx", a.px); gasCloud.setAttribute("cy", a.py);
        gasCloud.setAttribute("r", baseR * 1.6); 
        // é€™è£¡éœ€è¦ç¢ºä¿ plasma-grad- å­˜åœ¨ï¼Œå¦‚æœæ²’æœ‰å®šç¾©ï¼Œå›é€€åˆ°å–®è‰²
        // å»ºè­°ç›´æ¥ç”¨ atom-grad ä»¥ç¢ºä¿æœ‰é¡è‰²
        gasCloud.setAttribute("fill", `url(#atom-grad-${a.color.replace('#','')})`);
        gasCloud.setAttribute("filter", "url(#soft-glow)"); // åŠ ä¸Šå…‰æšˆ
        g.appendChild(gasCloud);

        const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
        txt.setAttribute("x", a.px); txt.setAttribute("y", a.py);
        txt.setAttribute("font-size", baseR * 0.85); 
        txt.setAttribute("class", "atom-label-text");
        txt.style.textShadow = "0 0 3px #000, 0 0 5px #000"; 
        txt.style.fill = "#fff";
        txt.textContent = a.elem;
        g.appendChild(txt);

    } else {
        const useGlow = document.getElementById('toggle-glow') ? document.getElementById('toggle-glow').checked : true;
        
        if (useGlow) {
            const glow = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            glow.setAttribute("cx", a.px); glow.setAttribute("cy", a.py); 
            
            // [é—œéµä¿®æ­£] ç§»é™¤æ‰‹æ©Ÿç‰ˆ mobile-glow åˆ†æ”¯ï¼Œçµ±ä¸€ä½¿ç”¨é›»è…¦ç‰ˆé‚è¼¯
            glow.setAttribute("r", a.r * a.scale * 1.3); 
            glow.setAttribute("fill", a.color); 
            glow.setAttribute("opacity", "0.36");
            glow.setAttribute("filter", "url(#soft-glow)"); // æ‰‹æ©Ÿç¾åœ¨ä¹Ÿè·‘é€™å€‹
            
            g.appendChild(glow);
        }

        const circle = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        circle.setAttribute("cx", a.px); circle.setAttribute("cy", a.py); 
        circle.setAttribute("r", a.r * a.scale); 
        circle.setAttribute("fill", `url(#atom-grad-${a.color.replace('#','')})`); 
        
        const txt = document.createElementNS("http://www.w3.org/2000/svg", "text");
        txt.setAttribute("x", a.px); txt.setAttribute("y", a.py); 
        txt.setAttribute("font-size", a.r * 0.75 * a.scale); 
        txt.setAttribute("class", "atom-label-text"); 
        txt.textContent = a.elem;
        
        g.appendChild(circle); g.appendChild(txt);
    }
    
    sceneRoot.appendChild(g);
}

// ========== [è«‹æ›¿æ› drawElectron] ==========
function drawElectron(e) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const r = e.r * e.scale;
    
    let coreColor = "#ffffff";
    let glowFill = "#ffffff";
    let glowOpacity = "0.28";
    
    if (e.isNegativeCharge) {
        coreColor = "#ff9efa"; 
        glowFill = "#ff9efa"; 
        glowOpacity = "0.5"; 
    }

    if (isPlasmaMode) {
        g.setAttribute("style", "mix-blend-mode: screen;"); 
        const halo = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        halo.setAttribute("cx", e.px); halo.setAttribute("cy", e.py);
        halo.setAttribute("r", r * (e.isNegativeCharge ? 3.0 : 2.0)); 
        halo.setAttribute("fill", glowFill);
        halo.setAttribute("opacity", "0.6");
        halo.setAttribute("filter", "url(#soft-glow)"); // [ä¿®æ­£] å¼·åˆ¶åŠ æ¿¾é¡
        g.appendChild(halo);

        const core = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        core.setAttribute("cx", e.px); core.setAttribute("cy", e.py);
        core.setAttribute("r", r * 1.0);
        core.setAttribute("fill", coreColor);
        core.setAttribute("class", "electron-spark"); 
        g.appendChild(core);

    } else {
        const useGlow = document.getElementById('toggle-glow') ? document.getElementById('toggle-glow').checked : true;
        if (useGlow) {
            const glow = document.createElementNS("http://www.w3.org/2000/svg", "circle");
            glow.setAttribute("cx", e.px); glow.setAttribute("cy", e.py); 
            
            // [é—œéµä¿®æ­£] ç§»é™¤æ‰‹æ©Ÿç‰¹åˆ¤ï¼Œå¼·åˆ¶çµ±ä¸€
            glow.setAttribute("r", r * 2.0); 
            glow.setAttribute("fill", glowFill);
            glow.setAttribute("opacity", glowOpacity);
            glow.setAttribute("filter", "url(#soft-glow)"); 
            
            g.appendChild(glow);
        }

        const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
        c.setAttribute("cx", e.px); c.setAttribute("cy", e.py); c.setAttribute("r", r);
        c.setAttribute("fill", coreColor); 
        c.setAttribute("opacity", "0.95");
        g.appendChild(c);
    }
    
    sceneRoot.appendChild(g);
}

function adjustColor(col, amt) {
    let usePound = false;
    if (col[0] == "#") { col = col.slice(1); usePound = true; }
    let num = parseInt(col,16);
    let r = (num >> 16) + amt; if (r > 255) r = 255; else if  (r < 0) r = 0;
    let b = ((num >> 8) & 0x00FF) + amt; if (b > 255) b = 255; else if  (b < 0) b = 0;
    let g = (num & 0x0000FF) + amt; if (g > 255) g = 255; else if (g < 0) g = 0;
    return (usePound?"#":"") + (g | (b << 8) | (r << 16)).toString(16).padStart(6,'0');
}

function animate() {
    const time = performance.now(); 
    if (!isDragging && !isReactionRunning && !isLongPressActive) {
        rotVelocity.x *= 0.96; rotVelocity.y *= 0.96; rotVelocity.z *= 0.96;
        let speed = Math.sqrt(rotVelocity.x*rotVelocity.x + rotVelocity.y*rotVelocity.y + rotVelocity.z*rotVelocity.z);
        const MIN_SPEED = 0.004; 
        const autoRotateEl = document.getElementById('toggle-auto-rotate');
        const isAutoRotateOn = autoRotateEl ? autoRotateEl.checked : true;

        if (speed > 0.00001) { 
            if (speed < MIN_SPEED) {
                if (isAutoRotateOn) {
                    let scaleFactor = MIN_SPEED / speed;
                    rotVelocity.x *= scaleFactor; rotVelocity.y *= scaleFactor; rotVelocity.z *= scaleFactor;
                }
            }
            applyRotation(rotVelocity.y, rotVelocity.x, rotVelocity.z);
        } else {
            if (isAutoRotateOn) applyRotation(0.004, 0, 0); 
        }
    }
    renderScene(time);
    requestAnimationFrame(animate);
}

function setupInteractions() {
    // 1. åŸºç¤æŒ‰éˆ•ç¶å®š
    const modeBtn = document.getElementById('mode-toggle');
    if (modeBtn) modeBtn.addEventListener('click', toggleMode);

    const loadBtn = document.getElementById('load-btn');
    if (loadBtn) loadBtn.addEventListener('click', handleLoadBtn);

    const inputField = document.getElementById('formula-input');
    if (inputField) {
        inputField.addEventListener('keydown', (e) => {
            if (e.key === 'Enter') handleLoadBtn();
        });
    }

    // 2. é¡¯ç¤ºè¨­å®šé–‹é—œ
    const toggleLp = document.getElementById('toggle-lp');
    if (toggleLp) toggleLp.addEventListener('change', () => { renderScene(); });

    const toggleGlow = document.getElementById('toggle-glow');
    if (toggleGlow) toggleGlow.addEventListener('change', () => { renderScene(); });

    const toggleOct = document.getElementById('toggle-octet');
    if (toggleOct) toggleOct.addEventListener('change', () => { 
        if(currentKey) loadMolecule(currentKey); 
    });

    const togglePlasma = document.getElementById('toggle-plasma');
    if (togglePlasma) {
        togglePlasma.addEventListener('change', (e) => {
            isPlasmaMode = e.target.checked;
            renderScene();
        });
    }

    // 3. [é—œéµä¿®å¾©] åæ‡‰æŒ‰éˆ•äº‹ä»¶ç¶å®š
    // å¿…é ˆä¸€ä¸€å°æ‡‰ HTML ID èˆ‡ä¸Šé¢å®šç¾©çš„å‡½å¼
    
    // ä¹™çƒ¯åæ‡‰
    const btnH2O = document.getElementById('reaction-btn');
    if(btnH2O) btnH2O.addEventListener('click', () => { isReactionRunning = true; runEthyleneHydration(); });

    const btnH2 = document.getElementById('reaction-h2-btn');
    if(btnH2) btnH2.addEventListener('click', () => { isReactionRunning = true; runEthyleneHydrogenation(); });

    const btnHCl = document.getElementById('reaction-hcl-btn');
    if(btnHCl) btnHCl.addEventListener('click', () => { isReactionRunning = true; runEthyleneHydrohalogenation(); });

    const btnCl2 = document.getElementById('reaction-cl2-btn');
    if(btnCl2) btnCl2.addEventListener('click', () => { isReactionRunning = true; runEthyleneChlorination(); });

    const btnKMnO4 = document.getElementById('reaction-kmno4-btn');
    if(btnKMnO4) btnKMnO4.addEventListener('click', () => { 
        isReactionRunning = true; 
        const name = getCurrentMoleculeName();
        // æ ¹æ“šç•¶å‰æ˜¯ ä¹™é†‡ é‚„æ˜¯ ä¹™çƒ¯ æ±ºå®šåŸ·è¡Œä»€éº¼åæ‡‰
        if (name === "ä¹™é†‡" || name === "é…’ç²¾") runEthanolStrongOxidation();
        else runEthyleneOxidation(); 
    });

    const btnOx = document.getElementById('reaction-ox-btn');
    if(btnOx) btnOx.addEventListener('click', () => {
        isReactionRunning = true;
        const name = getCurrentMoleculeName();
        // æ ¹æ“šç•¶å‰æ˜¯ ä¹™é†‡ é‚„æ˜¯ ä¹™é†› æ±ºå®šåŸ·è¡Œä»€éº¼åæ‡‰
        if(name === "ä¹™é†‡" || name === "é…’ç²¾") runEthanolMildOxidation();
        else if(name === "ä¹™é†›") runAcetaldehydeOxidation();
    });

    const btnRed = document.getElementById('reaction-red-btn');
    if(btnRed) btnRed.addEventListener('click', () => { isReactionRunning = true; runAcetaldehydeReduction(); });

    // ç”²çƒ·åæ‡‰
    const btnSub = document.getElementById('reaction-sub-btn');
    if(btnSub) btnSub.addEventListener('click', () => { isReactionRunning = true; runMethaneSubstitution(); });

    const btnNitro = document.getElementById('reaction-nitro-btn');
    if(btnNitro) btnNitro.addEventListener('click', () => { isReactionRunning = true; runMethaneNitration(); });

    // ä¸™çƒ¯åæ‡‰
    const btnPropH2 = document.getElementById('reaction-propene-h2-btn');
    if(btnPropH2) btnPropH2.addEventListener('click', () => { isReactionRunning = true; runPropeneHydrogenation(); });

    const btnPropCl2 = document.getElementById('reaction-propene-cl2-btn');
    if(btnPropCl2) btnPropCl2.addEventListener('click', () => { isReactionRunning = true; runPropeneChlorination(); });

    const btnPropHCl = document.getElementById('reaction-propene-hcl-btn');
    if(btnPropHCl) btnPropHCl.addEventListener('click', () => { isReactionRunning = true; runPropeneHydrohalogenation(); });

    const btnPropH2O = document.getElementById('reaction-propene-h2o-btn');
    if(btnPropH2O) btnPropH2O.addEventListener('click', () => { isReactionRunning = true; runPropeneHydration(); });

// [æ–°å¢] ä¹™ç‚”ç³»åˆ—æŒ‰éˆ•äº‹ä»¶ç¶å®š
    const btnAcetH2Full = document.getElementById('btn-c2h2-h2-full');
    if(btnAcetH2Full) btnAcetH2Full.addEventListener('click', () => { isReactionRunning = true; runAcetyleneFullHydrogenation(); });

    const btnAcetH2Part = document.getElementById('btn-c2h2-h2-part');
    if(btnAcetH2Part) btnAcetH2Part.addEventListener('click', () => { isReactionRunning = true; runAcetylenePartialHydrogenation(); });

    const btnAcetCl2Full = document.getElementById('btn-c2h2-cl2-full');
    if(btnAcetCl2Full) btnAcetCl2Full.addEventListener('click', () => { isReactionRunning = true; runAcetyleneFullHalogenation(); });

    const btnAcetCl2Part = document.getElementById('btn-c2h2-cl2-part');
    if(btnAcetCl2Part) btnAcetCl2Part.addEventListener('click', () => { isReactionRunning = true; runAcetylenePartialHalogenation(); });

    const btnAcetHClFull = document.getElementById('btn-c2h2-hcl-full');
    if(btnAcetHClFull) btnAcetHClFull.addEventListener('click', () => { isReactionRunning = true; runAcetyleneFullHydrohalogenation(); });

    const btnAcetHClPart = document.getElementById('btn-c2h2-hcl-part');
    if(btnAcetHClPart) btnAcetHClPart.addEventListener('click', () => { isReactionRunning = true; runAcetylenePartialHydrohalogenation(); });

    const btnAcetH2O = document.getElementById('btn-c2h2-h2o');
    if(btnAcetH2O) btnAcetH2O.addEventListener('click', () => { isReactionRunning = true; runAcetyleneHydration(); });

// 4. é‡ç½®æŒ‰éˆ• (ä¿®æ­£ç‚ºå‘¼å«çµ±ä¸€å‡½å¼)
    const resetBtn = document.getElementById('reset-btn');
    if (resetBtn) resetBtn.addEventListener('click', () => {
        // ç›´æ¥å‘¼å«ä¸Šé¢å®šç¾©å¥½çš„ resetReaction å‡½å¼
        // å®ƒæœƒè‡ªå‹•æ ¹æ“šç•¶å‰çš„ä¸­æ–‡åç¨±ï¼Œåˆ¤æ–·è¦è·³å›ä¹™çƒ¯ã€ä¸™çƒ¯é‚„æ˜¯ç”²çƒ·
        resetReaction();
    });

    const btnConfig = document.getElementById('btn-open-config');
    if(btnConfig) btnConfig.addEventListener('click', openConfigModal);


    // 5. æ‰‹æ©Ÿé¢æ¿èˆ‡éµç›¤
    const mobileHandle = document.getElementById('mobile-panel-handle');
    if (mobileHandle) {
        mobileHandle.addEventListener('click', () => {
            const body = document.body;
            body.classList.toggle('simulate-mobile-open');
            const panel = document.querySelector('.controls-area');
            if (panel) {
                if (body.classList.contains('simulate-mobile-open')) panel.style.transform = 'translateY(0)';
                else panel.style.transform = 'translateY(70vh)';
            }
        });
    }
    window.addEventListener('keydown', (e) => { if (e.key === 'Alt') altKeyIsDown = true; });
    window.addEventListener('keyup', (e) => { if (e.key === 'Alt') altKeyIsDown = false; });

    // 6. 3D æ‹–æ›³æ§åˆ¶
    const MOUSE_SENSITIVITY = 0.005; const TOUCH_SENSITIVITY = 0.004;
    let longPressTimer = null; let startX = 0, startY = 0;
    const LONG_PRESS_MS = 500; const MOVE_TOLERANCE = 10;

    const handleStart = (x, y) => { 
        isDragging = true; isLongPressActive = false; 
        startX = x; startY = y; lastMouse = { x, y }; 
        rotVelocity = { x: 0, y: 0, z: 0 }; hideHybridTooltip(); 
        clearTimeout(longPressTimer);
        longPressTimer = setTimeout(() => {
            isDragging = false; isLongPressActive = true; 
            checkAtomClick(x, y); 
            if (navigator.vibrate) navigator.vibrate(40);
        }, LONG_PRESS_MS);
    };

    const handleMove = (x, y, sensitivity) => {
        if (Math.abs(x - startX) > MOVE_TOLERANCE || Math.abs(y - startY) > MOVE_TOLERANCE) clearTimeout(longPressTimer);
        if (!isDragging) return;
        const dx = x - lastMouse.x; const dy = y - lastMouse.y;
        if (currentMode === 1 || (currentMode === 2 && !altKeyIsDown)) {
            rotVelocity.y = dx * sensitivity; rotVelocity.x = -dy * sensitivity; 
            applyRotation(rotVelocity.y, rotVelocity.x, 0);
        } else {
            panOffset.x += dx * 0.5; panOffset.y += dy * 0.5;
        }
        lastMouse = { x, y };
    };
    const handleEnd = () => { clearTimeout(longPressTimer); isDragging = false; isLongPressActive = false; };

    viewport.addEventListener("mousedown", e => handleStart(e.clientX, e.clientY));
    viewport.addEventListener("mousemove", e => handleMove(e.clientX, e.clientY, MOUSE_SENSITIVITY));
    viewport.addEventListener("mouseup", handleEnd);
    
    viewport.addEventListener("touchstart", e => {
        if(e.target.closest('.control-button') || e.target.closest('.suggestion-tag')) return;
        if (e.touches.length === 1) {
            handleStart(e.touches[0].clientX, e.touches[0].clientY);
        } else if (e.touches.length === 2) {
            clearTimeout(longPressTimer); 
            const t1 = e.touches[0], t2 = e.touches[1];
            lastTouchDist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            lastTouchCenter = { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
            lastTouchAngle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
        }
    }, { passive: false });

    viewport.addEventListener("touchmove", e => {
        e.preventDefault(); 
        if(e.touches.length === 1) {
            handleMove(e.touches[0].clientX, e.touches[0].clientY, TOUCH_SENSITIVITY);
        } else if (e.touches.length === 2) {
            const t1 = e.touches[0], t2 = e.touches[1];
            const center = { x: (t1.clientX + t2.clientX)/2, y: (t1.clientY + t2.clientY)/2 };
            panOffset.x += (center.x - lastTouchCenter.x) * 0.4;
            panOffset.y += (center.y - lastTouchCenter.y) * 0.4;
            lastTouchCenter = center;
            const dist = Math.hypot(t1.clientX - t2.clientX, t1.clientY - t2.clientY);
            if (lastTouchDist > 0) {
                const zoomDelta = (dist - lastTouchDist) * 0.003;
                scale = Math.max(0.3, Math.min(8, scale + zoomDelta));
            }
            lastTouchDist = dist;
            const angle = Math.atan2(t2.clientY - t1.clientY, t2.clientX - t1.clientX);
            let angleDelta = angle - lastTouchAngle;
            if (angleDelta > Math.PI) angleDelta -= Math.PI * 2;
            if (angleDelta < -Math.PI) angleDelta += Math.PI * 2;
            rotVelocity.z = angleDelta;
            applyRotation(0, 0, rotVelocity.z);
            lastTouchAngle = angle;
        }
    }, { passive: false });

    viewport.addEventListener("touchend", handleEnd);
    viewport.addEventListener("wheel", e => {
        scale = Math.max(0.5, Math.min(6, scale - e.deltaY * 0.001));
        hideHybridTooltip();
    });

    setupMobilePanel();
}

// ç¹ªè£½æ°´æ»´ç‹€èŠ±ç“£ (Bezier Curve)
function drawLobe(lobe) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const x1 = lobe.pStart.x; const y1 = lobe.pStart.y;
    const x2 = lobe.pEnd.x;   const y2 = lobe.pEnd.y;
    
    const dx = x2 - x1; const dy = y2 - y1;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len < 1) return;

    const width = 45 * lobe.scale; 
    const nx = -dy / len; const ny = dx / len; 

    const midX = x1 + dx * 0.6; const midY = y1 + dy * 0.6;
    const cp1x = midX + nx * width; const cp1y = midY + ny * width;
    const cp2x = midX - nx * width; const cp2y = midY - ny * width;

    const d = `M ${x1} ${y1} Q ${cp1x} ${cp1y} ${x2} ${y2} Q ${cp2x} ${cp2y} ${x1} ${y1} Z`;
    const path = document.createElementNS("http://www.w3.org/2000/svg", "path");
    path.setAttribute("d", d);
    
    const fillUrl = (lobe.colorType === 'd') ? "url(#grad-orb-d)" : "url(#grad-orb-p)";
    path.setAttribute("fill", fillUrl);
    path.setAttribute("stroke", (lobe.colorType === 'd') ? "#B45309" : "#047857");
    path.setAttribute("stroke-width", "1");
    path.setAttribute("opacity", "0.9"); 

    g.appendChild(path);
    sceneRoot.appendChild(g);
}

// â˜… æ–°ç‰ˆï¼šé«˜è³ªæ„Ÿé‡‘å±¬è»¸ (éŠ€ç°è»¸èº« + ç™½è‰²æ–‡å­— + ç„¡å‡¸é»ç®­é ­) â˜…
function drawAxisVector(axis) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const x1 = axis.pStart.x; const y1 = axis.pStart.y;
    const x2 = axis.pEnd.x;   const y2 = axis.pEnd.y;

    const dx = x2 - x1; const dy = y2 - y1;
    const len = Math.sqrt(dx*dx + dy*dy);
    if (len <= 0) return;

    // å–®ä½å‘é‡
    const ux = dx/len; const uy = dy/len;
    
    // ç®­é ­å°ºå¯¸
    const arrowSize = 10 * axis.scale;
    
    // è¨ˆç®—ç·šæ®µçµ‚é» (åœåœ¨ç®­é ­åº•éƒ¨ï¼Œé¿å…åœ“é ­å‡¸å‡º)
    const lineEndX = x2 - ux * (arrowSize - 2); 
    const lineEndY = y2 - uy * (arrowSize - 2);

    // 1. ç•«ç·š (éŠ€ç°è‰²ï¼Œå¹³é ­ Butt Cap)
    const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
    line.setAttribute("x1", x1); line.setAttribute("y1", y1);
    line.setAttribute("x2", lineEndX); line.setAttribute("y2", lineEndY);
    line.setAttribute("stroke", "#B0B0B0"); // é‡‘å±¬éŠ€ç°
    line.setAttribute("stroke-width", 2.5 * axis.scale);
    line.setAttribute("stroke-linecap", "butt"); // â˜… é—œéµï¼šå¹³é ­ï¼Œæ¶ˆé™¤å‡¸é»
    g.appendChild(line);

    // 2. ç•«ç®­é ­ (ä¸‰è§’å½¢)
    const bx = x2 - ux * arrowSize;
    const by = y2 - uy * arrowSize;
    const vx = -uy * arrowSize * 0.5;
    const vy = ux * arrowSize * 0.5;

    const pTip = `${x2},${y2}`;
    const pLeft = `${bx + vx},${by + vy}`;
    const pRight = `${bx - vx},${by - vy}`;

    const polygon = document.createElementNS("http://www.w3.org/2000/svg", "polygon");
    polygon.setAttribute("points", `${pTip} ${pLeft} ${pRight}`);
    polygon.setAttribute("fill", "#B0B0B0"); // åŒè‰²ç®­é ­
    g.appendChild(polygon);

    // 3. ç•«æ–‡å­— (ç´”ç™½ XYZ)
    if (axis.label) {
        const text = document.createElementNS("http://www.w3.org/2000/svg", "text");
        // æ–‡å­—ä½ç½®å¾€å¤–æ¨
        text.setAttribute("x", x2 + ux * 18 * axis.scale);
        text.setAttribute("y", y2 + uy * 18 * axis.scale);
        text.setAttribute("fill", "#FFFFFF"); // â˜… ç´”ç™½æ–‡å­—
        text.setAttribute("font-size", 16 * axis.scale);
        text.setAttribute("font-weight", "bold");
        text.setAttribute("text-anchor", "middle");
        text.setAttribute("dominant-baseline", "middle");
        text.style.textShadow = "0 0 3px #000000"; // åŠ ä¸€é»é™°å½±è®“ç™½è‰²æ›´æ¸…æ¥š
        text.textContent = axis.label;
        g.appendChild(text);
    }
    sceneRoot.appendChild(g);
}



function toChineseNum(num) { const map={1:'ä¸€',2:'äºŒ',3:'ä¸‰',4:'å››',5:'äº”',6:'å…­',7:'ä¸ƒ'}; return map[num]||num; }
// ========== [è«‹æ’å…¥é€™æ®µ JS] é›¢å­è¨ˆç®—é‚è¼¯ ==========
// ========== [è«‹æ’å…¥é€™æ®µ JS] 1. æ¨™æº–è»ŒåŸŸé †åº & 2. ç¸®å¯«è½‰æ›å™¨ ==========
const ORBITAL_ORDER = ['1s','2s','2p','3s','3p','4s','3d','4p','5s','4d','5p','6s','4f','5d','6p','7s','5f','6d','7p'];

// å°‡å®Œæ•´çµ„æ…‹è½‰ç‚ºæƒ°æ€§æ°£é«”ç¸®å¯« (ä¾‹å¦‚: 1s2 2s2 2p6 -> [Ne])
function toNobleNotation(fullConfig) {
    // å®šç¾©æƒ°æ€§æ°£é«”æ ¸å¿ƒ
    const nobles = [
        { sym: '[Rn]', conf: "1s2 2s2 2p6 3s2 3p6 3d10 4s2 4p6 4d10 5s2 5p6 4f14 5d10 6s2 6p6" },
        { sym: '[Xe]', conf: "1s2 2s2 2p6 3s2 3p6 3d10 4s2 4p6 4d10 5s2 5p6" },
        { sym: '[Kr]', conf: "1s2 2s2 2p6 3s2 3p6 3d10 4s2 4p6" },
        { sym: '[Ar]', conf: "1s2 2s2 2p6 3s2 3p6" },
        { sym: '[Ne]', conf: "1s2 2s2 2p6" },
        { sym: '[He]', conf: "1s2" }
    ];

    for (let gas of nobles) {
        if (fullConfig.startsWith(gas.conf) && fullConfig !== gas.conf) {
            // ç§»é™¤æ ¸å¿ƒéƒ¨åˆ†ï¼Œä¿ç•™å‰©ä¸‹çš„
            let rest = fullConfig.replace(gas.conf, "").trim();
            return `<span class="noble">${gas.sym}</span> ${rest}`;
        }
    }
    // å¦‚æœæ¯” He é‚„å° (ä¾‹å¦‚ H)ï¼Œç›´æ¥å›å‚³
    return fullConfig;
}
function calculateIonConfig(baseConfigStr, charge) {
    if (charge === 0) return baseConfigStr;

    const parts = baseConfigStr.split(' ');
    let orbitals = [];
    const typeVal = { 's':0, 'p':1, 'd':2, 'f':3 };
    // å®šç¾©å„è»ŒåŸŸå®¹é‡
    const capacity = { 's':2, 'p':6, 'd':10, 'f':14 };

    parts.forEach(p => {
        const match = p.match(/(\d)([spdf])(\d+)/);
        if (match) {
            orbitals.push({
                n: parseInt(match[1]),
                type: match[2],
                l: typeVal[match[2]],
                count: parseInt(match[3]),
                name: match[1] + match[2] // e.g., "1s"
            });
        }
    });

    // --- CASE A: é™½é›¢å­ (å¤±å»é›»å­) ---
    if (charge > 0) {
        let removeCount = charge;
        while (removeCount > 0) {
            let candidates = orbitals.filter(o => o.count > 0);
            if (candidates.length === 0) break;

            // æ’åºï¼šå…ˆæ‹” n æœ€å¤§ï¼Œn ç›¸åŒæ‹” l æœ€å¤§
            candidates.sort((a, b) => {
                if (b.n !== a.n) return b.n - a.n;
                return b.l - a.l;
            });

            let target = candidates[0];
            if (target.count >= removeCount) {
                target.count -= removeCount;
                removeCount = 0;
            } else {
                removeCount -= target.count;
                target.count = 0;
            }
        }
    } 
    // --- CASE B: é™°é›¢å­ (å¾—åˆ°é›»å­) ---
    else {
        let addCount = Math.abs(charge);
        
        // 1. å…ˆå˜—è©¦å¡«æ»¿ç¾æœ‰çš„æœ€å¾Œä¸€å€‹è»ŒåŸŸ
        // ä¾ç…§èƒ½é‡æ’åº (åŸæœ¬çš„å­—ä¸²é †åºé€šå¸¸å°±æ˜¯èƒ½é‡é †åºï¼Œé™¤äº†ä¾‹å¤–ï¼Œä½†é€™é‚Šæˆ‘å€‘ç°¡å–®è™•ç†)
        // ç‚ºäº†ä¿éšªï¼Œæˆ‘å€‘ç›´æ¥çœ‹æœ€å¾Œä¸€å€‹è»ŒåŸŸ
        while (addCount > 0) {
            let lastOrbital = orbitals[orbitals.length - 1];
            let maxCap = capacity[lastOrbital.type];

            if (lastOrbital.count < maxCap) {
                let space = maxCap - lastOrbital.count;
                let fill = Math.min(space, addCount);
                lastOrbital.count += fill;
                addCount -= fill;
            } else {
                // ç•¶å‰è»ŒåŸŸå·²æ»¿ï¼Œå°‹æ‰¾ä¸‹ä¸€å€‹è»ŒåŸŸ
                let currentName = lastOrbital.name; // e.g. "2p"
                let idx = ORBITAL_ORDER.indexOf(currentName);
                
                if (idx !== -1 && idx < ORBITAL_ORDER.length - 1) {
                    let nextName = ORBITAL_ORDER[idx + 1]; // e.g. "3s"
                    let nextMatch = nextName.match(/(\d)([spdf])/);
                    
                    // æ–°å¢ä¸€å€‹ç©ºè»ŒåŸŸåˆ°é™£åˆ—ä¸­
                    let newOrb = {
                        n: parseInt(nextMatch[1]),
                        type: nextMatch[2],
                        l: typeVal[nextMatch[2]],
                        count: 0, // åˆå§‹ç‚º0ï¼Œä¸‹ä¸€è¼ªè¿´åœˆæœƒå¡«å…¥
                        name: nextName
                    };
                    orbitals.push(newOrb);
                } else {
                    break; // è¶…å‡ºç¯„åœæˆ–æ‰¾ä¸åˆ°ï¼Œåœæ­¢ (é¿å…ç„¡çª®è¿´åœˆ)
                }
            }
        }
    }

    // é‡çµ„å­—ä¸²
    return orbitals
        .filter(o => o.count > 0)
        .map(o => `${o.n}${o.type}${o.count}`)
        .join(' ');
}

function generateEcViz(configStr) {
    const parts = configStr.split(' ');
    let html = '';
    parts.forEach(part => {
        const match = part.match(/(\d)([spdf])(\d+)/);
        if(match) {
            const level = match[1]; const type = match[2]; const count = parseInt(match[3]);
            const boxCount = {s:1, p:3, d:5, f:7}[type];
            let arrows = []; let e = count;
            for(let i=0; i<boxCount; i++) arrows[i] = "";
            for(let i=0; i<boxCount && e>0; i++, e--) arrows[i] = "â†‘";
            for(let i=0; i<boxCount && e>0; i++, e--) arrows[i] = "â‡…";
            let boxes = '';
            arrows.forEach(a => { boxes += `<div class="ec-box">${a || ''}</div>`; });
            html += `<div class="ec-sub"><div class="ec-boxes">${boxes}</div><div class="ec-label">${level}${type}<sup>${count}</sup></div></div>`;
        }
    });
    return html;
}

function renderConfigList() {
    const input = document.getElementById('configSearchInput');
    const filter = input ? input.value.toLowerCase() : "";
    const container = document.getElementById('configListContainer');
    container.innerHTML = "";

    ELECTRON_DATA.forEach(el => {
        if (filter && !el.s.toLowerCase().includes(filter) && 
            !el.n.toLowerCase().includes(filter) && 
            !el.z.toString().includes(filter)) {
            return;
        }

        const card = document.createElement('div');
        card.className = 'element-card';
        
        // é è¨­é¡¯ç¤ºï¼šç¸®å¯«ç‰ˆ
        // æˆ‘å€‘å°‡ "å®Œæ•´çµ„æ…‹" å­˜åœ¨ data-full-config å±¬æ€§ä¸­
        // å°‡ "ç•¶å‰é›»è·" å­˜åœ¨ data-charge å±¬æ€§ä¸­ (é è¨­0)
        // å°‡ "é¡¯ç¤ºæ¨¡å¼" å­˜åœ¨ data-mode å±¬æ€§ä¸­ (é è¨­ 'noble')
        
        let nobleHtml = el.noble.replace(/(\[.*?\])/g, '<span class="noble">$1</span>')
                                .replace(/([spdf])(\d+)/g, '$1<sup>$2</sup>');
        const vizHtml = generateEcViz(el.c);
        
        let periodGroupStr = "";
        if (el.g === "é‘­ç³»" || el.g === "éŒ’ç³»") {
            periodGroupStr = `ç¬¬${toChineseNum(el.p)}é€±æœŸ <span style="color:#f472b6;">${el.g}</span>`;
        } else {
            periodGroupStr = `ç¬¬${toChineseNum(el.p)}é€±æœŸ ${el.g}æ— (ç¬¬${el.iupac}æ—)`;
        }

        const cardId = `card-${el.s}`;

        card.innerHTML = `
            <div class="ec-header">
                <div class="ec-top-row">
                    <div class="ec-sym-box">
                        <div class="ec-sym">${el.s}</div>
                        <div class="ec-info">
                            <span class="ec-name">${el.cn ? el.cn + " " : ""}${el.n} <span style="color:#22d3ee; font-family:monospace;">Z=${el.z}</span></span>
                            <span class="ec-tag">${periodGroupStr}</span>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 6px;">
                                <div style="border:1px solid rgba(255,255,255,0.2); border-radius:6px; padding:3px 8px; font-size:0.75rem; color:#cbd5e1; background:rgba(20,20,20,0.3); white-space:nowrap;">åˆ†é¡: ${el.type || "-"}</div>
                                <div style="border:1px solid rgba(255,255,255,0.2); border-radius:6px; padding:3px 8px; font-size:0.75rem; color:#cbd5e1; background:rgba(20,20,20,0.3); white-space:nowrap;">ç‹€æ…‹: ${el.state || "-"}</div>
                                <div style="border:1px solid rgba(255,255,255,0.2); border-radius:6px; padding:3px 8px; font-size:0.75rem; color:#cbd5e1; background:rgba(20,20,20,0.3); white-space:nowrap;">ç†”é»: ${el.mp || "-"}</div>
                                <div style="border:1px solid rgba(255,255,255,0.2); border-radius:6px; padding:3px 8px; font-size:0.75rem; color:#cbd5e1; background:rgba(20,20,20,0.3); white-space:nowrap;">æ²¸é»: ${el.bp || "-"}</div>
                            </div>
                        </div>
                    </div>
                
                <!-- é¡¯ç¤ºæ¨¡å¼åˆ‡æ›æŒ‰éˆ• -->
                <button onclick="toggleConfigMode('${el.s}', '${el.c}')" style="font-size:0.75rem; background:rgba(255,255,255,0.1); border:1px solid #555; color:#aaa; border-radius:4px; padding:2px 6px; cursor:pointer;" id="${cardId}-mode-btn">
                    æ¨¡å¼: ç¸®å¯«
                </button>
            </div>
            
            <!-- é›¢å­æ§åˆ¶ -->
            <div id="ion-group-${el.s}" style="display:flex; gap:6px; margin:10px 0; flex-wrap:wrap; align-items:center;">
                <button class="ion-btn active" data-charge="0" data-type="neutral" onclick="updateIonViz('${el.s}', '${el.c}', 0)" 
                    style="font-size:0.75rem; padding:4px 8px; border:1px solid #64748b; border-radius:4px; color:#cbd5e1; background:#1e293b; cursor:pointer;">ä¸­æ€§</button>
                
                <button class="ion-btn" data-charge="1" data-type="pos" onclick="updateIonViz('${el.s}', '${el.c}', 1)" 
                    style="font-size:0.75rem; padding:4px 8px; border:1px solid #f87171; border-radius:4px; color:#f87171; background:rgba(248,113,113,0.1); cursor:pointer;">+1</button>
                <button class="ion-btn" data-charge="2" data-type="pos" onclick="updateIonViz('${el.s}', '${el.c}', 2)" 
                    style="font-size:0.75rem; padding:4px 8px; border:1px solid #f87171; border-radius:4px; color:#f87171; background:rgba(248,113,113,0.1); cursor:pointer;">+2</button>
                <button class="ion-btn" data-charge="3" data-type="pos" onclick="updateIonViz('${el.s}', '${el.c}', 3)" 
                    style="font-size:0.75rem; padding:4px 8px; border:1px solid #f87171; border-radius:4px; color:#f87171; background:rgba(248,113,113,0.1); cursor:pointer;">+3</button>
                
                <button class="ion-btn" data-charge="-1" data-type="neg" onclick="updateIonViz('${el.s}', '${el.c}', -1)" 
                    style="font-size:0.75rem; padding:4px 8px; border:1px solid #60a5fa; border-radius:4px; color:#60a5fa; background:rgba(96,165,250,0.1); cursor:pointer;">-1</button>
                <button class="ion-btn" data-charge="-2" data-type="neg" onclick="updateIonViz('${el.s}', '${el.c}', -2)" 
                    style="font-size:0.75rem; padding:4px 8px; border:1px solid #60a5fa; border-radius:4px; color:#60a5fa; background:rgba(96,165,250,0.1); cursor:pointer;">-2</button>
                <button class="ion-btn" data-charge="-3" data-type="neg" onclick="updateIonViz('${el.s}', '${el.c}', -3)" 
                    style="font-size:0.75rem; padding:4px 8px; border:1px solid #60a5fa; border-radius:4px; color:#60a5fa; background:rgba(96,165,250,0.1); cursor:pointer;">-3</button>
            </div>

                <!-- éš±è—æ¬„ä½ï¼šå„²å­˜ç•¶å‰é›»è·èˆ‡æ¨¡å¼ -->
                <input type="hidden" id="${cardId}-charge" value="0">
                <input type="hidden" id="${cardId}-mode" value="noble">

                <div class="ec-config-row ec-scroll" id="${cardId}-text" style="justify-content: flex-start;">
                    <div class="ec-config" style="white-space: nowrap;">${nobleHtml}</div>
                </div>
            </div>
            <div class="ec-scroll">
                <div class="ec-row" id="${cardId}-viz">
                    ${vizHtml}
                </div>
            </div>
        `;
        container.appendChild(card);
    });
}
// ========== [è«‹æ›¿æ› updateIonViz ä¸¦æ–°å¢ toggleConfigMode] ==========
// [ä¿®æ”¹] æ›´æ–°é›¢å­è¦–è¦ºåŒ– (åŠ å…¥æŒ‰éˆ•ç™¼äº®é‚è¼¯)
function updateIonViz(symbol, baseConfig, charge) {
    // 1. è¨ˆç®—é›¢å­çµ„æ…‹
    const newConfig = calculateIonConfig(baseConfig, charge);
    
    // 2. å–å¾—æ¨¡å¼èˆ‡å„²å­˜é›»è·
    const modeInput = document.getElementById(`card-${symbol}-mode`);
    const currentMode = modeInput ? modeInput.value : 'noble';
    const chargeInput = document.getElementById(`card-${symbol}-charge`);
    if(chargeInput) chargeInput.value = charge;

    // 3. ã€é—œéµã€‘åˆ‡æ›æŒ‰éˆ•ç‹€æ…‹ (é€™è£¡åªæ”¹ Classï¼Œä¸æ¶‰åŠè¤‡é›œé‹ç®—)
    const btnGroup = document.getElementById(`ion-group-${symbol}`);
    if (btnGroup) {
        // ä½¿ç”¨æœ€å‚³çµ±çš„ for è¿´åœˆï¼Œæ•ˆèƒ½æœ€å¥½
        const btns = btnGroup.getElementsByClassName('ion-btn');
        for (let i = 0; i < btns.length; i++) {
            let btn = btns[i];
            let btnCharge = parseInt(btn.getAttribute('data-charge'));
            if (btnCharge === charge) {
                btn.classList.add('active');
            } else {
                btn.classList.remove('active');
            }
        }
    }

    // 4. æ›´æ–°æ–‡å­—é¡¯ç¤º
    let displayHtml = (currentMode === 'noble') ? formatConfigHtml(toNobleNotation(newConfig)) : formatConfigHtml(newConfig);
    const textEl = document.getElementById(`card-${symbol}-text`);
    const color = charge > 0 ? '#f87171' : (charge < 0 ? '#60a5fa' : '#a5f3fc');
    if(textEl) textEl.innerHTML = `<div class="ec-config" style="color:${color}">${displayHtml}</div>`;
    
    // 5. æ›´æ–°è»ŒåŸŸåœ–
    const vizEl = document.getElementById(`card-${symbol}-viz`);
    if(vizEl) vizEl.innerHTML = generateEcViz(newConfig);
}

// åˆ‡æ›é¡¯ç¤ºæ¨¡å¼ (ç¸®å¯« <-> å®Œæ•´)
function toggleConfigMode(symbol, baseConfig) {
    const modeInput = document.getElementById(`card-${symbol}-mode`);
    const btn = document.getElementById(`card-${symbol}-mode-btn`);
    const chargeInput = document.getElementById(`card-${symbol}-charge`);
    
    if (modeInput && btn && chargeInput) {
        // åˆ‡æ›ç‹€æ…‹
        if (modeInput.value === 'noble') {
            modeInput.value = 'full';
            btn.textContent = "æ¨¡å¼: å®Œæ•´";
            btn.style.color = "#fff";
        } else {
            modeInput.value = 'noble';
            btn.textContent = "æ¨¡å¼: ç¸®å¯«";
            btn.style.color = "#aaa";
        }
        
        // è®€å–ç•¶å‰é›»è·ï¼Œé‡æ–°åˆ·æ–°é¡¯ç¤º
        const currentCharge = parseInt(chargeInput.value);
        updateIonViz(symbol, baseConfig, currentCharge);
    }
}

// è¼”åŠ©ï¼šHTML æ ¼å¼åŒ– (å°‡ [Ar] è®Šè‰²ï¼Œå°‡æ•¸å­—è®Šä¸Šæ¨™)
function formatConfigHtml(str) {
    return str.replace(/(\[.*?\])/g, '<span class="noble">$1</span>')
              .replace(/([spdf])(\d+)/g, '$1<sup>$2</sup>');
}

function openConfigModal() { const modal = document.getElementById('config-modal'); if(modal) { modal.style.display = 'flex'; renderConfigList(); } }
function closeConfigModal() { const modal = document.getElementById('config-modal'); if(modal) modal.style.display = 'none'; }


function checkAtomClick(screenX, screenY) {
    if (!currentMolecule || !currentMolecule.renderObjects) return;
    const bestMatch = findAtomByScreenPos(screenX, screenY);
    
    if (bestMatch) {
        if (currentMolecule.isIonic) {
            // æª¢æŸ¥æ˜¯å¦ç‚ºä»£è¡¨åŸå­ (æ“æœ‰å®Œæ•´é…ä½æ•¸çš„åŸå­)
            if (bestMatch.isRepresentative) {
                if (bestMatch.isHighlighted === "center") {
                    clearHighlights();
                } else {
                    highlightNeighbors(bestMatch);
                }
            } else {
                // é»æ“Šåˆ°é‚Šç·£æ®˜ç¼ºçš„åŸå­ -> è¦–ç‚ºå–æ¶ˆ
                // æ‚¨ä¹Ÿå¯ä»¥é¸æ“‡ alert("é€™æ˜¯æ™¶é«”é‚Šç·£ï¼Œé…ä½æ•¸ä¸å®Œæ•´")ï¼Œä½†é€™è£¡é¸æ“‡ç›´æ¥æ¸…é™¤æ¯”è¼ƒæµæš¢
                clearHighlights();
            }
        } else {
            showHybridInfo(bestMatch, screenX, screenY);
        }
    } else {
        hideHybridTooltip();
        if (currentMolecule && currentMolecule.isIonic) clearHighlights();
    }
}

// [ä¿®æ”¹] è¼”åŠ©å‡½å¼ï¼šé«˜äº®é„°å±… (åŸºæ–¼éµçµæ•¸æ“š)
function highlightNeighbors(centerAtom) {
    // 1. æ¸…é™¤èˆŠçš„é«˜äº®
    currentMolecule.renderObjects.forEach(obj => obj.isHighlighted = false);
    
    // 2. è¨­å®šä¸­å¿ƒåŸå­é«˜äº®
    centerAtom.isHighlighted = "center"; 
    
    let count = 0;
    const centerIdx = centerAtom.originalIndex; // å–å¾—åŸå§‹ç´¢å¼•

    // 3. éæ­·æ‰€æœ‰éµçµï¼Œæ‰¾å‡ºé€£æ¥çš„é„°å±…
    // åªæœ‰ç•¶éµçµå­˜åœ¨æ–¼æ•¸æ“šä¸­æ™‚ï¼Œæ‰è¦–ç‚ºé„°å±…
    if (currentMolecule.bonds3D) {
        currentMolecule.bonds3D.forEach(bond => {
            // bond[0] å’Œ bond[1] æ˜¯åŸå­çš„ç´¢å¼•
            let neighborIdx = -1;
            if (bond[0] === centerIdx) neighborIdx = bond[1];
            else if (bond[1] === centerIdx) neighborIdx = bond[0];

            if (neighborIdx !== -1) {
                // æ‰¾åˆ°é„°å±…ç‰©ä»¶
                const neighbor = currentMolecule.renderObjects.find(obj => obj.type === 'atom' && obj.originalIndex === neighborIdx);
                if (neighbor) {
                    neighbor.isHighlighted = "neighbor";
                    count++;
                }
            }
        });
    }
    
    // 4. æ›´æ–°æç¤ºæ–‡å­— (åŠ å…¥åŸå­åç¨±)
    const tooltip = document.getElementById('hybrid-label');
    if(tooltip) {
        tooltip.innerHTML = `<div style="text-align:center;">
            <span style="color:#facc15; font-weight:bold; font-size:1.2em;">${centerAtom.elem}</span>
            <br>é…ä½æ•¸: <span style="color:#fff; font-weight:bold; font-size:1.4em;">${count}</span>
        </div>`;
        tooltip.classList.add('show');
    }
    
    renderScene();
}

function clearHighlights() {
    if(!currentMolecule) return;
    currentMolecule.renderObjects.forEach(obj => obj.isHighlighted = false);
    renderScene();
}

function findAtomByScreenPos(screenX, screenY) {
    const atomGroups = document.querySelectorAll("g[data-atom-idx]");
    let candidates = [];
    atomGroups.forEach(g => {
        const idx = parseInt(g.getAttribute("data-atom-idx"));
        const atomData = currentMolecule.renderObjects[idx];
        if (!atomData) return;
        const circle = g.querySelector("circle");
        if (!circle) return;
        const rect = circle.getBoundingClientRect();
        const cx = rect.left + rect.width / 2;
        const cy = rect.top + rect.height / 2;
        const dist = Math.hypot(screenX - cx, screenY - cy);
        if (dist < (rect.width / 2 + 10)) {
            const p = project(atomData);
            candidates.push({ atom: atomData, z: p.z, dist: dist });
        }
    });
    if (candidates.length === 0) return null;
    candidates.sort((a, b) => b.z - a.z);
    return candidates[0].atom;
}

// ========== [è«‹æ›¿æ› showHybridInfo å‡½å¼] ==========
function showHybridInfo(atomObj, x, y) {
    const tooltip = document.getElementById('hybrid-label');
    if(!tooltip) return;

    const atomIdx = atomObj.originalIndex;
    let sigmaCount = 0;
    if (currentMolecule.bonds3D) {
        currentMolecule.bonds3D.forEach(b => {
            if (b[0] === atomIdx || b[1] === atomIdx) {
                sigmaCount++;
            }
        });
    }
    
    const lpCount = atomObj.calculatedLP || 0;
    const sum = sigmaCount + lpCount;
    
    // è¨ˆç®—å½¢å¼é›»è·æ•¸æ“š
    const props = ELEMENT_PROPS[atomObj.elem];
    const ve = props ? props.ve : "?";
    const dots = (lpCount * 2) + (atomObj.radical ? 1 : 0);
    let bondLines = 0;
    if (currentMolecule.bonds3D) {
        currentMolecule.bonds3D.forEach(b => {
            if (b[0] === atomIdx || b[1] === atomIdx) {
                let type = b[2] || "single";
                if (type.includes("triple")) bondLines += 3;
                else if (type.includes("double")) bondLines += 2;
                else if (type === "coordinate") bondLines += 1; 
                else if (type === "coordinate_triple") bondLines += 3;
                else bondLines += 1;
            }
        });
    }

    const fc = atomObj.formalCharge || 0;
    let fcStr = fc > 0 ? `+${fc}` : `${fc}`;
    let fcColor = fc === 0 ? "#9ca3af" : (fc > 0 ? "#f87171" : "#60a5fa");

    // [ä¿®æ”¹] è¨ˆç®—éç¨‹å­—ä¸²ï¼šç·š -> éµ
    const calcStr = `<div style="font-size:0.8em; color:#bbb; margin-top:4px; border-top:1px solid #444; padding-top:2px;">(åƒ¹${ve} - é»${dots} - éµ${bondLines})</div>`;

    let contentHtml = `<span style="color:var(--accent-blue);font-size:1.5em;line-height:1.2;font-weight:bold;">${atomObj.elem}</span>`;
    
    // [ä¿®æ”¹] èª¿æ•´é¡¯ç¤ºé †åº
    if (sigmaCount >= 2) { 
        let hybrid = "";
        let hybridColor = "#ffffff"; 
        if (sum === 2) { hybrid = "sp"; hybridColor = "#22d3ee"; } 
        else if (sum === 3) { hybrid = "spÂ²"; hybridColor = "#a3e635"; } 
        else if (sum === 4) { hybrid = "spÂ³"; hybridColor = "#fbbf24"; } 
        else if (sum === 5) { hybrid = "spÂ³d"; hybridColor = "#f472b6"; } 
        else if (sum === 6) { hybrid = "spÂ³dÂ²"; hybridColor = "#818cf8"; } 
        else { hybrid = "-"; }

        // 1. é¡¯ç¤ºæ··æˆ
        contentHtml += `<div style="margin-top:4px;">æ··æˆ: <span style="color:${hybridColor};font-size:1.2em">${hybrid}</span></div>`;
        
        // 2. é¡¯ç¤º Sigma + LP è¨ˆç®— (ç§»åˆ°æ··æˆä¸‹æ–¹)
        contentHtml += `<div style="font-size:0.8em;color:#888;margin-top:2px;margin-bottom:6px;">(&sigma;:${sigmaCount} + LP:${lpCount} = ${sum})</div>`;
        
        // 3. é¡¯ç¤ºå½¢å¼é›»è· (æ–‡å­—æ”¹ç‚º "å½¢å¼é›»è·")
        contentHtml += `<div>å½¢å¼é›»è·: <span style="color:${fcColor};font-size:1.2em;font-weight:bold">${fcStr}</span></div>`;
        
        // 4. é¡¯ç¤ºå½¢å¼é›»è·è¨ˆç®—å…¬å¼ (æ”¾åœ¨æœ€ä¸‹æ–¹)
        contentHtml += calcStr;
        // =====================================

    } else {  
        contentHtml += `<div style="margin-top:4px;">é›»è·: <span style="color:${fcColor};font-size:1.4em;font-weight:bold">${fcStr}</span></div>`;
        if(atomObj.elem === 'H') contentHtml += `<div style="font-size:0.8em;color:#888;">(1s)</div>`;
        
        // [ä¿®æ”¹] è¨ˆç®—éç¨‹æ”¾åœ¨æœ€å¾Œ
        contentHtml += calcStr;
    }

    tooltip.innerHTML = contentHtml;
    tooltip.classList.add('show');
}

function hideHybridTooltip() {
    const tooltip = document.getElementById('hybrid-label');
    if (tooltip) tooltip.classList.remove('show');
}

function setupMobilePanel() {
    const panel = document.querySelector('.controls-area');
    const handle = document.getElementById('mobile-panel-handle');
    
    if(!handle || !panel || window.innerWidth > 768) return;

    // --- è¨­å®šåƒæ•¸ ---
    const HANDLE_H = 40; 
    const PANEL_H = window.innerHeight * 0.8; 
    
    // å®šç¾©ä¸‰å€‹åœé é»
    const POS_OPEN = 0; 
    const POS_HALF = PANEL_H - (window.innerHeight * 0.35); // éœ²å‡ºç´„ 35%
    const POS_CLOSE = PANEL_H - HANDLE_H;

    let startY = 0;
    let startTransY = POS_HALF;
    let currentTransY = POS_HALF;
    let startTime = 0;
    let isDragging = false;

    // [åˆå§‹åŒ–] é è¨­ä½ç½®åœ¨åŠé–‹ï¼Œæ‰€ä»¥åŠ ä¸Š half-open é¡åˆ¥
    panel.style.transform = `translateY(${POS_HALF}px)`; 
    panel.classList.add('half-open');

    // 1. è§¸æ‘¸é–‹å§‹
    handle.addEventListener('touchstart', (e) => {
        if(e.cancelable) e.preventDefault();
        e.stopPropagation();

        isDragging = true;
        handle.classList.add('active'); 

        startY = e.touches[0].clientY;
        startTime = new Date().getTime();

        const style = window.getComputedStyle(panel);
        const matrix = new WebKitCSSMatrix(style.transform);
        startTransY = matrix.m42; 

        panel.style.transition = 'none';
    }, {passive: false});

    // 2. è§¸æ‘¸ç§»å‹•
    window.addEventListener('touchmove', (e) => {
        if(!isDragging) return;
        if(e.cancelable) e.preventDefault(); 

        const currentY = e.touches[0].clientY;
        const deltaY = currentY - startY;
        
        let newY = startTransY + deltaY;

        // é‚Šç•Œé˜»å°¼
        if (newY < POS_OPEN) newY = newY * 0.4; 
        if (newY > POS_CLOSE) newY = POS_CLOSE + (newY - POS_CLOSE) * 0.1; 

        panel.style.transform = `translateY(${newY}px)`;
        currentTransY = newY;
    }, {passive: false});

    // [è¼”åŠ©å‡½å¼] æ›´æ–°é¢æ¿ç‹€æ…‹ (æ§åˆ¶åº•éƒ¨ç•™ç™½)
    const updatePanelState = (targetY) => {
        // å¦‚æœç›®æ¨™æ˜¯åŠé–‹ä½ç½®ï¼ŒåŠ ä¸Š classï¼›å¦å‰‡ç§»é™¤
        // æˆ‘å€‘å…è¨±ä¸€é»èª¤å·® (Math.abs < 10)
        if (Math.abs(targetY - POS_HALF) < 10) {
            panel.classList.add('half-open');
        } else {
            panel.classList.remove('half-open');
        }
    };

    // 3. è§¸æ‘¸çµæŸ
    window.addEventListener('touchend', (e) => {
        if(!isDragging) return;
        isDragging = false;
        e.stopPropagation();

        handle.classList.remove('active');
        panel.style.transition = 'transform 0.4s cubic-bezier(0.19, 1, 0.22, 1)';

        const endTime = new Date().getTime();
        const duration = endTime - startTime;
        const moveDist = currentTransY - startTransY;
        const velocity = Math.abs(moveDist) / duration;

        let targetY = POS_CLOSE;

        // [ä¿®æ­£] åˆ†æ®µæ»‘å‹•é‚è¼¯
        if (velocity > 0.3) {
            // å¿«é€Ÿæ»‘å‹•
            if (moveDist < 0) { 
                // å¾€ä¸Šæ»‘ (Up)
                // å¦‚æœåŸæœ¬åœ¨åŠé–‹ä»¥ä¸Šï¼Œå°±å…¨é–‹ï¼›å¦å‰‡å»åŠé–‹
                targetY = (startTransY > POS_HALF + 50) ? POS_HALF : POS_OPEN;
            } else {
                // å¾€ä¸‹æ»‘ (Down)
                // å¦‚æœåŸæœ¬æ˜¯å…¨é–‹ (æ¥è¿‘0)ï¼Œå…ˆåœåŠé–‹ï¼›å¦å‰‡é—œé–‰
                targetY = (startTransY < POS_HALF - 50) ? POS_HALF : POS_CLOSE;
            }
        } else {
            // æ…¢é€Ÿæ‹–æ›³ï¼šæ‰¾æœ€è¿‘çš„é»
            const distToOpen = Math.abs(currentTransY - POS_OPEN);
            const distToHalf = Math.abs(currentTransY - POS_HALF);
            const distToClose = Math.abs(currentTransY - POS_CLOSE);

            if (distToOpen < distToHalf && distToOpen < distToClose) targetY = POS_OPEN;
            else if (distToHalf < distToClose) targetY = POS_HALF;
            else targetY = POS_CLOSE;
        }

        panel.style.transform = `translateY(${targetY}px)`;
        updatePanelState(targetY); // æ›´æ–°ç•™ç™½ç‹€æ…‹
    });

    // 4. é»æ“ŠæŠŠæ‰‹åˆ‡æ›
    handle.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        
        handle.classList.add('active');
        setTimeout(() => handle.classList.remove('active'), 200);

        const style = window.getComputedStyle(panel);
        const matrix = new WebKitCSSMatrix(style.transform);
        const currentY = matrix.m42;

        panel.style.transition = 'transform 0.5s cubic-bezier(0.19, 1, 0.22, 1)';
        
        let targetY = POS_CLOSE;

        // å¾ªç’°é‚è¼¯ï¼šé—œ -> åŠ -> é–‹ -> é—œ
        if (Math.abs(currentY - POS_CLOSE) < 50) targetY = POS_HALF;      // é—œ -> åŠ
        else if (Math.abs(currentY - POS_HALF) < 50) targetY = POS_OPEN;  // åŠ -> é–‹
        else targetY = POS_CLOSE;                                         // é–‹ -> é—œ

        panel.style.transform = `translateY(${targetY}px)`;
        updatePanelState(targetY); // æ›´æ–°ç•™ç™½ç‹€æ…‹
    });
}


// ===============================================
// 1. ç³»çµ±å‚™ä»½èˆ‡åˆå§‹åŒ– (4K é«˜æ¸…é›»å­é›²ç‰ˆ)
// ===============================================

if (!window._nativeRenderScene) {
    window._nativeRenderScene = window.renderScene;
    window._nativeLoadMolecule = window.loadMolecule;
}

window.currentOrbitalMode = false;
window.currentOrbitalType = null;
window.showNodalPlanes = true;
window.isHighDensityMode = true; 

const AXIS_LEN = 150;

// â˜… å„ªåŒ–ï¼šæ”¯æ´ Retina/High-DPI è¢å¹•ï¼Œè§£æ±ºæ¨¡ç³Šå•é¡Œ
function ensureCanvasLayer() {
    const viewport = document.getElementById('viewport');
    let canvas = document.getElementById('orbital-canvas');
    if (!canvas) {
        canvas = document.createElement('canvas');
        canvas.id = 'orbital-canvas';
        canvas.style.position = 'absolute';
        canvas.style.top = '0';
        canvas.style.left = '0';
        canvas.style.width = '100%';
        canvas.style.height = '100%';
        canvas.style.pointerEvents = 'none'; 
        canvas.style.zIndex = '10'; 
        viewport.appendChild(canvas);
    }
    
    // å–å¾—è£ç½®åƒç´ æ¯” (Retina è¢å¹•é€šå¸¸æ˜¯ 2 æˆ– 3)
    const dpr = window.devicePixelRatio || 1;
    const rect = viewport.getBoundingClientRect();

    // å¦‚æœç•«å¸ƒå¯¦éš›åƒç´ å°ºå¯¸ä¸ç¬¦ï¼Œå‰‡é‡è¨­ (é¿å…æ¯å¹€é‡è¨­å°è‡´é–ƒçˆï¼Œåªåœ¨è¦–çª—æ”¹è®Šæ™‚è§¸ç™¼)
    // æˆ‘å€‘çµ¦å¯¬é«˜åŠ ä¸€é»ç·©è¡ï¼Œé¿å…å°æ•¸é»èª¤å·®å°è‡´é »ç¹é‡ç¹ª
    if (Math.abs(canvas.width - rect.width * dpr) > 1 || 
        Math.abs(canvas.height - rect.height * dpr) > 1) {
        
        canvas.width = rect.width * dpr;
        canvas.height = rect.height * dpr;
        
        // CSS å°ºå¯¸ç¶­æŒèˆ‡è¦–çª—ä¸€è‡´ (ç€è¦½å™¨æœƒè‡ªå‹•ç¸®æ”¾ï¼Œä½†å› ç‚ºæˆ‘å€‘åƒç´ å¤ å¤šï¼Œç¸®æ”¾å¾Œå°±å¾ˆæ¸…æ™°)
        // æ³¨æ„ï¼šé€™è£¡ä¸éœ€è¦è¨­å®š style.width/heightï¼Œå› ç‚ºä¸Šé¢å·²ç¶“è¨­å®š width:100%
        
        // å„²å­˜ dpr ä¾›æ¸²æŸ“æ™‚ä½¿ç”¨
        canvas.dpr = dpr;
    }
    return canvas;
}

// 2. è»ŒåŸŸæ•¸æ“šé…ç½®
const ORBITAL_DATA = {
    "s":  { sphere: {r:80, color:"blue"}, planes:[], label:"1s" },
    
    "px": { lobes: [{e:[160,0,0],color:"blue"}, {e:[-160,0,0],color:"orange"}], planes:[{type:'yz'}], label:"2px" },
    "py": { lobes: [{e:[0,160,0],color:"blue"}, {e:[0,-160,0],color:"orange"}], planes:[{type:'xz'}], label:"2py" },
    "pz": { lobes: [{e:[0,0,160],color:"blue"}, {e:[0,0,-160],color:"orange"}], planes:[{type:'xy'}], label:"2pz" },
    
    "dxy": { lobes: [{e:[110,110,0],color:"blue"}, {e:[-110,-110,0],color:"blue"}, {e:[-110,110,0],color:"orange"}, {e:[110,-110,0],color:"orange"}], planes:[{type:'xz'},{type:'yz'}], label:"3dxy" },
    "dyz": { lobes: [{e:[0,110,110],color:"blue"}, {e:[0,-110,-110],color:"blue"}, {e:[0,-110,110],color:"orange"}, {e:[0,110,-110],color:"orange"}], planes:[{type:'xy'},{type:'xz'}], label:"3dyz" },
    "dxz": { lobes: [{e:[110,0,110],color:"blue"}, {e:[-110,0,-110],color:"blue"}, {e:[-110,0,110],color:"orange"}, {e:[110,0,-110],color:"orange"}], planes:[{type:'xy'},{type:'yz'}], label:"3dxz" },
    "dx2-y2": { lobes: [{e:[150,0,0],color:"blue"}, {e:[-150,0,0],color:"blue"}, {e:[0,150,0],color:"orange"}, {e:[0,-150,0],color:"orange"}], planes:[{type:'custom',v:[{x:80,y:80,z:80},{x:-80,y:-80,z:80},{x:-80,y:-80,z:-80},{x:80,y:80,z:-80}]},{type:'custom',v:[{x:80,y:-80,z:80},{x:-80,y:80,z:80},{x:-80,y:80,z:-80},{x:80,y:-80,z:-80}]}], label: "3dxÂ²-yÂ²" },   
    "dz2": { lobes: [{e:[0,0,150],color:"blue"}, {e:[0,0,-150],color:"blue"}], torus:{r:80,color:"orange"}, planes:[], label:"3dzÂ²" },

    // --- f è»ŒåŸŸ (Cube Set) ---
    // ç‰¹å¾µï¼šå…©å€‹ä¸»èŠ±ç“£ + å…©å€‹ç’° (Double Torus)
    "fz3": { 
        lobes: [{e:[0,0,160],color:"blue"}, {e:[0,0,-160],color:"orange"}], 
        tori: [{r:55, color:"orange", offset:25, normal:[0,0,1]}, {r:55, color:"blue", offset:-25, normal:[0,0,1]}],
        label: "4fzÂ³" 
    },
    "fx3": { 
        lobes: [{e:[160,0,0],color:"blue"}, {e:[-160,0,0],color:"orange"}], 
        tori: [{r:55, color:"orange", offset:25, normal:[1,0,0]}, {r:55, color:"blue", offset:-25, normal:[1,0,0]}],
        label: "4fxÂ³" 
    },
    "fy3": { 
        lobes: [{e:[0,160,0],color:"blue"}, {e:[0,-160,0],color:"orange"}], 
        tori: [{r:55, color:"orange", offset:25, normal:[0,1,0]}, {r:55, color:"blue", offset:-25, normal:[0,1,0]}],
        label: "4fyÂ³" 
    },

    // --- f è»ŒåŸŸ (General Set) ---
    // ç‰¹å¾µï¼š8 å€‹èŠ±ç“£æŒ‡å‘ç«‹æ–¹é«”çš„è§’è½
    "fxyz": { 
        lobes: [
            {e:[100,100,100],color:"blue"}, {e:[-100,-100,100],color:"blue"}, {e:[-100,100,-100],color:"blue"}, {e:[100,-100,-100],color:"blue"},
            {e:[-100,-100,-100],color:"orange"}, {e:[100,100,-100],color:"orange"}, {e:[100,-100,100],color:"orange"}, {e:[-100,100,100],color:"orange"}
        ], 
        label: "4fxyz" 
    },
    // ä¸‹é¢ä¸‰å€‹å½¢ç‹€é¡ä¼¼ xyz ä½†æ—‹è½‰ 45 åº¦ï¼Œæˆ‘å€‘ç”¨ 8 å€‹èŠ±ç“£æ¨¡æ“¬åœ–ä¸­çš„æ¨£å­
    "f_z_x2y2": { 
        lobes: [
            {e:[120,0,80],color:"blue"}, {e:[-120,0,80],color:"blue"}, {e:[0,120,-80],color:"blue"}, {e:[0,-120,-80],color:"blue"},
            {e:[0,120,80],color:"orange"}, {e:[0,-120,80],color:"orange"}, {e:[120,0,-80],color:"orange"}, {e:[-120,0,-80],color:"orange"}
        ], 
        label: "4fz(xÂ²-yÂ²)" 
    },
    "f_x_z2y2": { 
        lobes: [
            {e:[80,120,0],color:"blue"}, {e:[80,-120,0],color:"blue"}, {e:[-80,0,120],color:"blue"}, {e:[-80,0,-120],color:"blue"},
            {e:[80,0,120],color:"orange"}, {e:[80,0,-120],color:"orange"}, {e:[-80,120,0],color:"orange"}, {e:[-80,-120,0],color:"orange"}
        ], 
        label: "4fx(zÂ²-yÂ²)" 
    },
    "f_y_z2x2": { 
        lobes: [
            {e:[0,80,120],color:"blue"}, {e:[0,80,-120],color:"blue"}, {e:[120,-80,0],color:"blue"}, {e:[-120,-80,0],color:"blue"},
            {e:[120,80,0],color:"orange"}, {e:[-120,80,0],color:"orange"}, {e:[0,-80,120],color:"orange"}, {e:[0,-80,-120],color:"orange"}
        ], 
        label: "4fy(zÂ²-xÂ²)" 
    }
};

// 3. UI åˆå§‹åŒ–
function initOrbitalUI() {
    if(document.getElementById('orbital-card')) return;
    const container = document.querySelector('.controls-content');
    if(!container) return;
    const card = document.createElement('div');
    card.id = 'orbital-card'; card.className = 'card'; card.style.border = '1px solid rgba(56, 189, 248, 0.4)';
    card.innerHTML = `
        <div class="card-title" style="color:#38bdf8;">ğŸ’  åŸå­è»ŒåŸŸ</div>
        
        <!-- s, p è»ŒåŸŸ -->
        <div class="orbital-btn-group" style="grid-template-columns: 1fr 1fr 1fr 1fr;">
            <button class="orb-btn" onclick="loadOrbital('s')">s</button>
            <button class="orb-btn" onclick="loadOrbital('px')">p<sub>x</sub></button>
            <button class="orb-btn" onclick="loadOrbital('py')">p<sub>y</sub></button>
            <button class="orb-btn" onclick="loadOrbital('pz')">p<sub>z</sub></button>
        </div>
        
        <!-- d è»ŒåŸŸ -->
        <div class="orbital-btn-group" style="grid-template-columns: repeat(5, 1fr);">
            <button class="orb-btn" onclick="loadOrbital('dxy')">d<sub>xy</sub></button>
            <button class="orb-btn" onclick="loadOrbital('dyz')">d<sub>yz</sub></button>
            <button class="orb-btn" onclick="loadOrbital('dxz')">d<sub>xz</sub></button>
            <button class="orb-btn" onclick="loadOrbital('dx2-y2')">d<sub>xÂ²-yÂ²</sub></button>
            <button class="orb-btn" onclick="loadOrbital('dz2')">d<sub>zÂ²</sub></button>
        </div>

        <!-- f è»ŒåŸŸ (æ–°å¢) -->
        <div style="font-size:0.8rem; color:#aaa; margin-top:5px; margin-bottom:2px;">f è»ŒåŸŸ (Cubic Set):</div>
        <div class="orbital-btn-group" style="grid-template-columns: repeat(3, 1fr);">
            <button class="orb-btn" onclick="loadOrbital('fz3')">f<sub>zÂ³</sub></button>
            <button class="orb-btn" onclick="loadOrbital('fx3')">f<sub>xÂ³</sub></button>
            <button class="orb-btn" onclick="loadOrbital('fy3')">f<sub>yÂ³</sub></button>
        </div>
        
        <div style="font-size:0.8rem; color:#aaa; margin-top:5px; margin-bottom:2px;">f è»ŒåŸŸ (General Set):</div>
        <div class="orbital-btn-group" style="grid-template-columns: repeat(4, 1fr);">
            <button class="orb-btn" onclick="loadOrbital('fxyz')">f<sub>xyz</sub></button>
            <button class="orb-btn" onclick="loadOrbital('f_z_x2y2')">f<sub>z(xÂ²-yÂ²)</sub></button>
            <button class="orb-btn" onclick="loadOrbital('f_x_z2y2')">f<sub>x(zÂ²-yÂ²)</sub></button>
            <button class="orb-btn" onclick="loadOrbital('f_y_z2x2')">f<sub>y(zÂ²-xÂ²)</sub></button>
        </div>

        <button id="btn-toggle-plane" class="control-button plane-toggle active" onclick="togglePlanes()">é¡¯ç¤ºç¯€é¢: ON</button>
    `;
    const dataCard = document.getElementById('data-card');
    if(dataCard && dataCard.parentNode) dataCard.parentNode.insertBefore(card, dataCard);
    else container.appendChild(card);
}

// 4. ç´”é›»å­é›²ç”Ÿæˆå¼•æ“ (é«˜å¯†åº¦å‹•æ…‹ç‰ˆ)
function generateCloudPoints(type) {
    const data = ORBITAL_DATA[type];
    const points = [];
    // [ä¿®æ”¹] å¤§å¹…æå‡ç²’å­æ•¸é‡ (4500 -> 20000) è®“é›²å±¤æ›´ç¶¿å¯†
    const DOT_COUNT = 20000; 

    // è¼”åŠ©ï¼šåŠ å…¥éš¨æ©Ÿå‹•ç•«åƒæ•¸
    const createPoint = (x, y, z, color) => ({
        x, y, z, color,
        // [æ–°å¢] æ¯å€‹ç²’å­ç¨ç«‹çš„é¡«å‹•åƒæ•¸
        phase: Math.random() * Math.PI * 2, 
        speed: 0.002 + Math.random() * 0.004
    });

    const addLobePoints = (baseV, color, count) => {
        const len = Math.sqrt(baseV[0]**2 + baseV[1]**2 + baseV[2]**2) || 1;
        const dx = baseV[0]/len, dy = baseV[1]/len, dz = baseV[2]/len;

        let tx = 0, ty = 1, tz = 0;
        if (Math.abs(dx) < 0.1 && Math.abs(dz) < 0.1) { tx=1; ty=0; tz=0; }
        let ux = dy*tz - dz*ty, uy = dz*tx - dx*tz, uz = dx*ty - dy*tx; 
        const uLen = Math.sqrt(ux*ux + uy*uy + uz*uz);
        ux/=uLen; uy/=uLen; uz/=uLen;
        let wx = dy*uz - dz*uy, wy = dz*ux - dx*uz, wz = dx*uy - dy*ux;

        for(let i=0; i<count; i++) {
            let d = Math.pow(Math.random(), 0.7); 
            const dist = d * 160; 
            // è®“èŠ±ç“£ç¨å¾®æ”¶æ–‚ä¸€é»ï¼Œå½¢ç‹€æ›´éŠ³åˆ©
            let r = Math.sin(d * Math.PI) * 38; 
            r *= Math.sqrt(Math.random()); 
            const theta = Math.random() * Math.PI * 2;
            const rc = r * Math.cos(theta);
            const rs = r * Math.sin(theta);
            
            points.push(createPoint(
                dist * dx + rc * ux + rs * wx,
                dist * dy + rc * uy + rs * wy,
                dist * dz + rc * uz + rs * wz,
                color
            ));
        }
    };

    // s è»ŒåŸŸ
    if (data.sphere) {
        for(let i=0; i<DOT_COUNT; i++) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            let r = 80 * Math.pow(Math.random(), 1/3);
            if (Math.random() > 0.6) r = 80 * Math.abs(generateGaussian()) * 0.6;
            
            points.push(createPoint(
                r * Math.sin(phi) * Math.cos(theta),
                r * Math.sin(phi) * Math.sin(theta),
                r * Math.cos(phi),
                "#38bdf8"
            ));
        }
    }

    // p, d, f è»ŒåŸŸ (èŠ±ç“£)
    if (data.lobes) {
        const countPerLobe = Math.floor(DOT_COUNT / data.lobes.length);
        data.lobes.forEach(lobe => {
            const color = (lobe.color === 'blue') ? "#38bdf8" : "#fbbf24";
            addLobePoints(lobe.e, color, countPerLobe);
        });
    }

    // d è»ŒåŸŸ (å–®ç’°)
    if (data.torus) {
        const ringCount = 2500; // [ä¿®æ”¹] å¢åŠ ç’°çš„å¯†åº¦
        const color = (data.torus.color === 'blue') ? "#38bdf8" : "#fbbf24";
        for(let i=0; i<ringCount; i++) {
            const theta = Math.random() * Math.PI * 2;
            const ringR = 60 + (generateGaussian()) * 10; 
            const tubeH = (Math.random() - 0.5) * 20;
            
            points.push(createPoint(
                ringR * Math.cos(theta),
                ringR * Math.sin(theta),
                tubeH,
                color
            ));
        }
    }

    // f è»ŒåŸŸ (å¤šé‡ç’°)
    if (data.tori) {
        const ringCount = 2000; // [ä¿®æ”¹] å¢åŠ ç’°çš„å¯†åº¦
        data.tori.forEach(torus => {
            const color = (torus.color === 'blue') ? "#38bdf8" : "#fbbf24";
            let nx = torus.normal[0], ny = torus.normal[1], nz = torus.normal[2];
            let len = Math.sqrt(nx*nx + ny*ny + nz*nz);
            nx/=len; ny/=len; nz/=len;

            let tx = 0, ty = 1, tz = 0; 
            if (Math.abs(nx) < 0.1 && Math.abs(nz) < 0.1) { tx=1; ty=0; tz=0; }
            let ux = ny*tz - nz*ty, uy = nz*tx - nx*tz, uz = nx*ty - ny*tx; 
            let uLen = Math.sqrt(ux*ux + uy*uy + uz*uz); 
            ux/=uLen; uy/=uLen; uz/=uLen;
            let vx = ny*uz - nz*uy, vy = nz*ux - nx*uz, vz = nx*uy - ny*ux;

            for(let i=0; i<ringCount; i++) {
                const theta = Math.random() * Math.PI * 2;
                const rBase = torus.r || 50;
                const ringR = rBase + (generateGaussian()) * 8; 
                const tubeH = (Math.random() - 0.5) * 15 + (torus.offset || 0);

                let px = ringR * Math.cos(theta);
                let py = ringR * Math.sin(theta);
                let pz = tubeH;

                points.push(createPoint(
                    px * ux + py * vx + pz * nx,
                    px * uy + py * vy + pz * ny,
                    px * uz + py * vz + pz * nz,
                    color
                ));
            }
        });
    }

    return points;
}

function generateGaussian() {
    let u = 0, v = 0;
    while(u === 0) u = Math.random(); 
    while(v === 0) v = Math.random();
    return Math.sqrt( -2.0 * Math.log( u ) ) * Math.cos( 2.0 * Math.PI * v );
}

// 5. æ¸²æŸ“è¿´åœˆ (åŠ å…¥å¾®å¹…æŠ–å‹•å‹•ç•«)
function renderOrbitals() {
    const sceneRoot = document.getElementById("scene-root"); 
    sceneRoot.innerHTML = "";
    
    const canvas = ensureCanvasLayer();
    const ctx = canvas.getContext('2d');
    const dpr = canvas.dpr || 1;
    const time = performance.now(); // å–å¾—ç•¶å‰æ™‚é–“

    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ctx.scale(dpr, dpr);
    ctx.translate(canvas.width / dpr / 2, canvas.height / dpr / 2);

    if(!currentMolecule || !currentMolecule.renderObjects) return;

    // ç¹ªè£½é›»å­é›²
    if (currentMolecule.cloudPoints) {
        const projected = [];
        
        // æŠ•å½±æ™‚åŠ å…¥å¾®å¹…æŠ–å‹•
        currentMolecule.cloudPoints.forEach(p => {
            // [æ–°å¢] æ ¹æ“šæ™‚é–“èˆ‡ç›¸ä½è¨ˆç®—åç§»é‡ (Jitter)
            // ç¯„åœç´„ +/- 1.5 å–®ä½ï¼Œè£½é€  "é›»å­ä¸ç¢ºå®šæ€§" çš„æ„Ÿè¦º
            const jitterX = Math.cos(time * p.speed + p.phase) * 1.5;
            const jitterY = Math.sin(time * p.speed + p.phase) * 1.5;
            const jitterZ = Math.sin(time * p.speed * 1.3 + p.phase) * 1.5;

            // å°‡åç§»é‡åŠ åˆ°åŸå§‹åº§æ¨™
            const proj = project({
                x: p.x + jitterX,
                y: p.y + jitterY,
                z: p.z + jitterZ
            }); 

            if (proj.scale > 0) {
                projected.push({ ...proj, color: p.color });
            }
        });

        // ç¹ªåœ–è¨­å®š
        ctx.globalCompositeOperation = 'lighter'; // è®“é‡ç–Šè™•ç™¼å…‰
        
        projected.forEach(p => {
            // ç²’å­å¤§å°ï¼šéš¨ç¸®æ”¾è®ŠåŒ–ï¼Œä½†ä¿æŒåœ¨åˆç†ç¯„åœ
            const size = Math.max(0.6, 1.1 * p.scale); 
            
            ctx.fillStyle = p.color;
            // [ä¿®æ”¹] é™ä½ä¸é€æ˜åº¦ï¼šå› ç‚ºå¯†åº¦å¢åŠ 4å€ï¼Œé€æ˜åº¦è¦é™ä½ä»¥å…è®Šæˆå¯¦å¿ƒè‰²å¡Š
            // å¾ 0.6 é™åˆ° 0.25ï¼Œé€™æ¨£å †ç–Šèµ·ä¾†æ‰æœ‰é›²éœ§æ„Ÿ
            ctx.globalAlpha = 0.25; 
            
            ctx.beginPath();
            ctx.arc(p.x, p.y, size, 0, Math.PI * 2);
            ctx.fill();
        });
        
        ctx.globalCompositeOperation = 'source-over';
        ctx.globalAlpha = 1.0;
    }

    // ç¹ªè£½ SVG è¼”åŠ©ç·š (ç¯€é¢èˆ‡è»¸) - ä¿æŒä¸è®Š
    const renderList = [];
    currentMolecule.renderObjects.forEach(obj => {
        if (obj.type === 'axisVector') {
            const pStart = project(obj.start); const pEnd = project(obj.end);
            renderList.push({ type:'axisVector', z:(pStart.z+pEnd.z)/2, pStart, pEnd, label:obj.label, scale:pStart.scale });
        } else if (obj.type === 'plane' && showNodalPlanes) {
             const poly = (function(t,v){ 
                const s=100; if(v)return v; 
                if(t==='xy')return[{x:s,y:s,z:0},{x:-s,y:s,z:0},{x:-s,y:-s,z:0},{x:s,y:-s,z:0}];
                if(t==='yz')return[{x:0,y:s,z:s},{x:0,y:-s,z:s},{x:0,y:-s,z:-s},{x:0,y:s,z:-s}];
                if(t==='xz')return[{x:s,y:0,z:s},{x:s,y:0,z:-s},{x:-s,y:0,z:-s},{x:-s,y:0,z:s}]; return [];
            })(obj.planeType, obj.customV);
            const proj = poly.map(p => project(p));
            renderList.push({ type:'plane', z:proj.reduce((s,p)=>s+p.z,0)/proj.length, points:proj });
        }
    });

    renderList.sort((a,b) => a.z - b.z).forEach(obj => {
        if (obj.type === "plane") drawPlane(obj, sceneRoot);
        else if (obj.type === "axisVector") drawAxisVectorInSVG(obj, sceneRoot);
    });
}

// 6. SVG è¼”åŠ©ç¹ªåœ–å‡½æ•¸
function drawPlane(plane, root) {
    let pts=""; plane.points.forEach(p=>{pts+=`${p.x},${p.y} `});
    const p=document.createElementNS("http://www.w3.org/2000/svg","polygon"); p.setAttribute("points",pts); 
    p.setAttribute("fill","rgba(255,255,255,0.1)"); p.setAttribute("stroke","rgba(255,255,255,0.3)"); 
    root.appendChild(p);
}

function drawAxisVectorInSVG(axis, root) {
    const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
    const x1 = axis.pStart.x; const y1 = axis.pStart.y;
    const x2 = axis.pEnd.x;   const y2 = axis.pEnd.y;
    const l = document.createElementNS("http://www.w3.org/2000/svg", "line");
    l.setAttribute("x1", x1); l.setAttribute("y1", y1); l.setAttribute("x2", x2); l.setAttribute("y2", y2);
    l.setAttribute("stroke", "#9ca3af"); l.setAttribute("stroke-width", 2);
    g.appendChild(l);
    if (axis.label) {
        const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
        t.setAttribute("x", x2 + (x2-x1)*0.1); t.setAttribute("y", y2 + (y2-y1)*0.1);
        t.textContent = axis.label; t.setAttribute("fill", "white"); t.setAttribute("font-size", 14);
        g.appendChild(t);
    }
    root.appendChild(g);
}

// 7. ç³»çµ±æ›è¼‰
window.renderScene = function(time) {
    if (window.currentOrbitalMode) renderOrbitals();
    else {
        const canvas = document.getElementById('orbital-canvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        window._nativeRenderScene(time);
    }
};

window.loadMolecule = function(key, variant) {
    // [ä¿®æ­£] 1. å¼·åˆ¶é—œé–‰è»ŒåŸŸæ¨¡å¼
    window.currentOrbitalMode = false;
    window.currentOrbitalType = null;
    
    // [ä¿®æ­£] 2. æ¸…é™¤è»ŒåŸŸ Canvas ç•«é¢ (é¿å…æ®˜ç•™)
    const canvas = document.getElementById('orbital-canvas');
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }
    
    // [ä¿®æ­£] 3. ç§»é™¤æŒ‰éˆ•æ´»æ€§ç‹€æ…‹
    document.querySelectorAll('.orb-btn').forEach(b => b.classList.remove('active'));
    
    // åŸ·è¡ŒåŸæœ¬çš„è¼‰å…¥é‚è¼¯
    window._nativeLoadMolecule(key, variant);
};

window.loadOrbital = function(type) {
    window.currentOrbitalMode = true;
    window.currentOrbitalType = type;
    document.querySelectorAll('.orb-btn').forEach(b => b.classList.remove('active'));
    const targetBtn = document.querySelector(`button[onclick="loadOrbital('${type}')"]`);
    if(targetBtn) targetBtn.classList.add('active');

    const data = ORBITAL_DATA[type];
    let objs = [];

    objs.push({ type:'axisVector', start:{x:-AXIS_LEN,y:0,z:0}, end:{x:AXIS_LEN,y:0,z:0}, label:'x' });
    objs.push({ type:'axisVector', start:{x:0,y:-AXIS_LEN,z:0}, end:{x:0,y:AXIS_LEN,z:0}, label:'y' });
    objs.push({ type:'axisVector', start:{x:0,y:0,z:-AXIS_LEN}, end:{x:0,y:0,z:AXIS_LEN}, label:'z' });

    if (showNodalPlanes && data.planes) data.planes.forEach(p => objs.push({ type:'plane', planeType:p.type, customV:p.v }));

    currentMolecule = { fullKey:`Orbital|${data.label}`, renderObjects:objs, bonds3D:[] };
    currentMolecule.cloudPoints = generateCloudPoints(type);

    const n = document.getElementById('info-name'); if(n) n.textContent = `è»ŒåŸŸ: ${data.label}`;
    const f = document.getElementById('info-formula'); if(f) f.innerHTML = "";

    renderScene();
};

window.togglePlanes = function() {
    showNodalPlanes = !showNodalPlanes;
    const btn = document.getElementById('btn-toggle-plane');
    if(btn) { 
        btn.textContent = `é¡¯ç¤ºç¯€é¢: ${showNodalPlanes?"ON":"OFF"}`; 
        btn.classList.toggle('active', showNodalPlanes);
    }
    if(currentOrbitalMode && currentOrbitalType) loadOrbital(currentOrbitalType);
};

setTimeout(initOrbitalUI, 500);

// ==========================================
// [ç³»çµ±ä¿®å¾©] è§£æ±ºè»ŒåŸŸé‡ç–Šå•é¡Œ & ç¢ºä¿ç•«é¢æ¸…é™¤
// ==========================================

// 1. è¦†å¯«æ¸²æŸ“è¿´åœˆï¼šç¢ºä¿éè»ŒåŸŸæ¨¡å¼ä¸‹ï¼Œæ¯ä¸€å¹€éƒ½å¼·åˆ¶æ¸…ç©º Canvas
window.renderScene = function(time) {
    if (window.currentOrbitalMode) {
        // å¦‚æœæ˜¯è»ŒåŸŸæ¨¡å¼ï¼ŒåŸ·è¡Œè»ŒåŸŸæ¸²æŸ“
        renderOrbitals();
    } else {
        // å¦‚æœæ˜¯æ™®é€šåˆ†å­æ¨¡å¼
        const canvas = document.getElementById('orbital-canvas');
        if (canvas) {
            const ctx = canvas.getContext('2d');
            // â˜…é—œéµä¿®æ­£ï¼šæ¸…é™¤å‰å¿…é ˆé‡ç½®çŸ©é™£ (Reset Transform)
            // å¦å‰‡ clearRect åªæœƒæ¸…é™¤åç§»å¾Œçš„å€åŸŸï¼Œå°è‡´ç•«é¢æ®˜ç•™
            ctx.setTransform(1, 0, 0, 1, 0, 0); 
            ctx.clearRect(0, 0, canvas.width, canvas.height);
        }
        // å‘¼å«åŸæœ¬çš„ SVG æ¸²æŸ“
        window._nativeRenderScene(time);
    }
};

// 2. è¦†å¯«è¼‰å…¥å‡½å¼ï¼šåˆ‡æ›åˆ†å­æ™‚ï¼Œç«‹å³é‡ç½®ç‹€æ…‹
window.loadMolecule = function(key, variant) {
    // é—œé–‰è»ŒåŸŸæ——æ¨™
    window.currentOrbitalMode = false;
    window.currentOrbitalType = null;
    
    // ç«‹å³æ¸…é™¤ Canvas (é›™é‡ä¿éšª)
    const canvas = document.getElementById('orbital-canvas');
    if (canvas) {
        const ctx = canvas.getContext('2d');
        ctx.setTransform(1, 0, 0, 1, 0, 0); // é‡ç½®çŸ©é™£
        ctx.clearRect(0, 0, canvas.width, canvas.height); // æ¸…ç©º
    }
    
    // ç§»é™¤æŒ‰éˆ•æ´»æ€§
    document.querySelectorAll('.orb-btn').forEach(b => b.classList.remove('active'));
    
    // åŸ·è¡ŒåŸå§‹è¼‰å…¥
    window._nativeLoadMolecule(key, variant);
};

</script>
</body>
</html>
